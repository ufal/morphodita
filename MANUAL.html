<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta name="generator" content="http://txt2tags.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>MorphoDiTa: Morphological Dictionary and Tagger</title>
</head>
<body>

<div class="header" id="header">
<h1>MorphoDiTa: Morphological Dictionary and Tagger</h1>
<h2>Version 1.11.2</h2>
</div>

<div class="toc">

  <ol>
  <li><a href="#introduction">Introduction</a>
  </li>
  <li><a href="#online">Online Web Application and Web Service</a>
  </li>
  <li><a href="#release">Release</a>
    <ul>
    <li><a href="#download">3.1. Download</a>
      <ul>
      <li><a href="#language_models">3.1.1. Language Models</a>
      </li>
      </ul>
    </li>
    <li><a href="#license">3.2. License</a>
    </li>
    </ul>
  </li>
  <li><a href="#instalation">MorphoDiTa Installation</a>
    <ul>
    <li><a href="#requirements">4.1. Requirements</a>
    </li>
    <li><a href="#compilation">4.2. Compilation</a>
      <ul>
      <li><a href="#compilation_platforms">4.2.1. Platforms</a>
      </li>
      <li><a href="#compilation_further_details">4.2.2. Further Details</a>
      </li>
      </ul>
    </li>
    <li><a href="#other_language_bindings">4.3. Other language bindings</a>
      <ul>
      <li><a href="#csharp_installation">4.3.1. C#</a>
      </li>
      <li><a href="#java_installation">4.3.2. Java</a>
      </li>
      <li><a href="#perl_installation">4.3.3. Perl</a>
      </li>
      <li><a href="#python_installation">4.3.4. Python</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  <li><a href="#users_manual">MorphoDiTa User's Manual</a>
    <ul>
    <li><a href="#czech-morfflex2-pdtc">5.1. Czech MorfFlex2+PDT-C Models</a>
      <ul>
      <li><a href="#czech-morfflex2-pdtc_download">5.1.1. Download</a>
      </li>
      <li><a href="#czech-morfflex2-pdtc_acknowledgements">5.1.2. Acknowledgements</a>
      </li>
      <li><a href="#czech_morfflex2_system">5.1.3. MorfFlex CZ 2.0 Morphological System</a>
      </li>
      <li><a href="#czech-morfflex2-pdtc_split">5.1.4. PDT-C 1.0 Train/Dev/Test Split</a>
      </li>
      <li><a href="#czech-morfflex2-pdtc_variants">5.1.5. Model Variants</a>
      </li>
      <li><a href="#czech-morfflex2-pdtc_performance">5.1.6. Model Performance</a>
      </li>
      </ul>
    </li>
    <li><a href="#czech-morfflex-pdt">5.2. Czech MorfFlex+PDT Models</a>
      <ul>
      <li><a href="#czech-morfflex-pdt_download">5.2.1. Download</a>
      </li>
      <li><a href="#czech-morfflex-pdt_acknowledgements">5.2.2. Acknowledgements</a>
      </li>
      <li><a href="#czech_morphological_system">5.2.3. Czech Morphological System</a>
      </li>
      <li><a href="#czech-morfflex-pdt_model">5.2.4. Main Czech Model</a>
      </li>
      <li><a href="#czech-morfflex-pdt_pos_variant">5.2.5. Part of Speech Only Variant</a>
      </li>
      <li><a href="#czech-morfflex-pdt_no_dia_variant">5.2.6. No Diacritical Marks Variant</a>
      </li>
      <li><a href="#czech-morfflex-pdt_raw_lemmas_variant">5.2.7. Models with Raw Lemmas</a>
      </li>
      <li><a href="#czech-morfflex-pdt_changes">5.2.8. Czech Model History</a>
      </li>
      </ul>
    </li>
    <li><a href="#slovak-morfflex-pdt">5.3. Slovak MorfFlex+PDT Models</a>
      <ul>
      <li><a href="#slovak-morfflex-pdt_download">5.3.1. Download</a>
      </li>
      <li><a href="#slovak-morfflex-pdt_acknowledgements">5.3.2. Acknowledgements</a>
      </li>
      <li><a href="#slovak_morphological_system">5.3.3. Slovak Morphological System</a>
      </li>
      <li><a href="#slovak-morfflex-pdt_model">5.3.4. Main Slovak Model</a>
      </li>
      <li><a href="#slovak-morfflex-pdt_pos_variant">5.3.5. Part of Speech Only Variant</a>
      </li>
      <li><a href="#slovak-morfflex-pdt_no_dia_variant">5.3.6. No Diacritical Marks Variant</a>
      </li>
      </ul>
    </li>
    <li><a href="#english-morphium-wsj">5.4. English Morphium+WSJ Models</a>
      <ul>
      <li><a href="#english-morphium-wsj_download">5.4.1. Download</a>
      </li>
      <li><a href="#english-morphium-wsj_acknowledgements">5.4.2. Acknowledgements</a>
      </li>
      <li><a href="#english-morphium-wsj_morphological_system">5.4.3. English Morphological System</a>
      </li>
      <li><a href="#english-morphium-wsj_model">5.4.4. English Model</a>
      </li>
      <li><a href="#english-morphium-wsj_no_negations_variant">5.4.5. No Negations Variant</a>
      </li>
      <li><a href="#english-morphium-wsj_changes">5.4.6. English Model Changes</a>
      </li>
      </ul>
    </li>
    <li><a href="#run_tagger">5.5. Running the Tagger</a>
      <ul>
      <li><a href="#tagger_input_formats">5.5.1. Input Formats</a>
      </li>
      <li><a href="#tagger_tagset_conversion">5.5.2. Tag Set Conversion</a>
      </li>
      <li><a href="#tagger_derivation">5.5.3. Morphological Derivation</a>
      </li>
      <li><a href="#tagger_morpho_guesser">5.5.4. Morphological Guesser</a>
      </li>
      <li><a href="#tagger_output_formats">5.5.5. Output Formats</a>
      </li>
      </ul>
    </li>
    <li><a href="#running_morphology">5.6. Running the Morphology</a>
      <ul>
      <li><a href="#run_morpho_analyze">5.6.1. Morphological Analysis</a>
      </li>
      <li><a href="#run_morpho_generate">5.6.2. Morphological Generation</a>
      </li>
      <li><a href="#run_morpho_cli">5.6.3. Interactive Morphological Analysis and Generation</a>
      </li>
      </ul>
    </li>
    <li><a href="#run_tokenizer">5.7. Running the Tokenizer</a>
      <ul>
      <li><a href="#run_tokenizer_output_formats">5.7.1. Output Formats</a>
      </li>
      </ul>
    </li>
    <li><a href="#rest_server">5.8. Running REST Server</a>
    </li>
    <li><a href="#custom_models">5.9. Custom Morphological and Tagging Models</a>
      <ul>
      <li><a href="#custom_morphological_models">5.9.1. Custom Morphological Models</a>
      </li>
      <li><a href="#custom_tagging_models">5.9.2. Custom Tagging Models</a>
      </li>
      </ul>
    </li>
    </ul>
  </li>
  <li><a href="#api_tutorial">MorphoDiTa API Tutorial</a>
    <ul>
    <li><a href="#tutorial_tagger_api">6.1. Tagger API</a>
    </li>
    <li><a href="#tutorial_morpho_api">6.2. Morphological Dictionary API</a>
      <ul>
      <li><a href="#tutorial_morpho_construction">6.2.1. Dictionary Construction</a>
      </li>
      <li><a href="#tutorial_morpho_analysis">6.2.2. Morphological Analysis</a>
      </li>
      <li><a href="#tutorial_morpho_generation">6.2.3. Generation</a>
      </li>
      </ul>
    </li>
    <li><a href="#faq">6.3. Questions and Answers</a>
    </li>
    </ul>
  </li>
  <li><a href="#api_reference">MorphoDiTa API Reference</a>
    <ul>
    <li><a href="#versioning">7.1. MorphoDiTa Versioning</a>
    </li>
    <li><a href="#lemma_structure">7.2. Lemma Structure</a>
    </li>
    <li><a href="#string_piece">7.3. Struct string_piece</a>
    </li>
    <li><a href="#tagged_form">7.4. Struct tagged_form</a>
    </li>
    <li><a href="#tagged_lemma">7.5. Struct tagged_lemma</a>
    </li>
    <li><a href="#tagged_lemma_forms">7.6. Struct tagged_lemma_forms</a>
    </li>
    <li><a href="#token_range">7.7. Struct token_range</a>
    </li>
    <li><a href="#derivated_lemma">7.8. Struct derivated_lemma</a>
    </li>
    <li><a href="#version">7.9. Class version</a>
      <ul>
      <li><a href="#version_current">7.9.1. version::current</a>
      </li>
      </ul>
    </li>
    <li><a href="#tokenizer">7.10. Class tokenizer</a>
      <ul>
      <li><a href="#tokenizer_set_text">7.10.1. tokenizer::set_text</a>
      </li>
      <li><a href="#tokenizer_next_sentence">7.10.2. tokenizer::next_sentence</a>
      </li>
      <li><a href="#tokenizer_new_vertical_tokenizer">7.10.3. tokenizer::new_vertical_tokenizer</a>
      </li>
      <li><a href="#tokenizer_new_czech_tokenizer">7.10.4. tokenizer::new_czech_tokenizer</a>
      </li>
      <li><a href="#tokenizer_new_english_tokenizer">7.10.5. tokenizer::new_english_tokenizer</a>
      </li>
      <li><a href="#tokenizer_new_generic_tokenizer">7.10.6. tokenizer::new_generic_tokenizer</a>
      </li>
      </ul>
    </li>
    <li><a href="#derivator">7.11. Class derivator</a>
      <ul>
      <li><a href="#derivator_parent">7.11.1. derivator::parent</a>
      </li>
      <li><a href="#derivator_children">7.11.2. derivator::children</a>
      </li>
      </ul>
    </li>
    <li><a href="#derivation_formatter">7.12. Class derivation_formatter</a>
      <ul>
      <li><a href="#derivation_formatter_format_derivation">7.12.1. derivation_formatter::format_derivation</a>
      </li>
      <li><a href="#derivation_formatter_format_tagged_lemma">7.12.2. derivation_formatter::format_tagged_lemma</a>
      </li>
      <li><a href="#derivation_formatter_format_tagged_lemmas">7.12.3. derivation_formatter::format_tagged_lemmas</a>
      </li>
      <li><a href="#derivation_formatter_new_none_derivation_formatter">7.12.4. derivation_formatter::new_none_derivation_formatter</a>
      </li>
      <li><a href="#derivation_formatter_new_root_derivation_formatter">7.12.5. derivation_formatter::new_root_derivation_formatter</a>
      </li>
      <li><a href="#derivation_formatter_new_path_derivation_formatter">7.12.6. derivation_formatter::new_path_derivation_formatter</a>
      </li>
      <li><a href="#derivation_formatter_new_tree_derivation_formatter">7.12.7. derivation_formatter::new_tree_derivation_formatter</a>
      </li>
      <li><a href="#derivation_formatter_new_derivation_formatter">7.12.8. derivation_formatter::new_derivation_formatter</a>
      </li>
      </ul>
    </li>
    <li><a href="#morpho">7.13. Class morpho</a>
      <ul>
      <li><a href="#morpho_load_cstring">7.13.1. morpho::load(const char*)</a>
      </li>
      <li><a href="#morpho_load_istream">7.13.2. morpho::load(istream&amp;)</a>
      </li>
      <li><a href="#morpho_guesser_mode">7.13.3. morpho::guesser_mode</a>
      </li>
      <li><a href="#morpho_analyze">7.13.4. morpho::analyze()</a>
      </li>
      <li><a href="#morpho_generate">7.13.5. morpho::generate()</a>
      </li>
      <li><a href="#morpho_raw_lemma_len">7.13.6. morpho::raw_lemma_len</a>
      </li>
      <li><a href="#morpho_lemma_id_len">7.13.7. morpho::lemma_id_len</a>
      </li>
      <li><a href="#morpho_raw_form_len">7.13.8. morpho::raw_form_len</a>
      </li>
      <li><a href="#morpho_new_tokenizer">7.13.9. morpho::new_tokenizer</a>
      </li>
      <li><a href="#morpho_get_derivator">7.13.10. morpho::get_derivator</a>
      </li>
      </ul>
    </li>
    <li><a href="#tagger">7.14. Class tagger</a>
      <ul>
      <li><a href="#tagger_load_cstring">7.14.1. tagger::load(const char*)</a>
      </li>
      <li><a href="#tagger_load_istream">7.14.2. tagger::load(istream&amp;)</a>
      </li>
      <li><a href="#tagger_get_morpho">7.14.3. tagger::get_morpho()</a>
      </li>
      <li><a href="#tagger_tag">7.14.4. tagger::tag()</a>
      </li>
      <li><a href="#tagger_tag_analyzed">7.14.5. tagger::tag_analyzed()</a>
      </li>
      <li><a href="#tagger_new_tokenizer">7.14.6. tagger::new_tokenizer</a>
      </li>
      </ul>
    </li>
    <li><a href="#tagset_converter">7.15. Class tagset_converter</a>
      <ul>
      <li><a href="#tagset_converter_convert">7.15.1. tagset_converter::convert()</a>
      </li>
      <li><a href="#tagset_converter_convert_analyzed">7.15.2. tagset_converter::convert_analyzed()</a>
      </li>
      <li><a href="#tagset_converter_convert_generated">7.15.3. tagset_converter::convert_generated()</a>
      </li>
      <li><a href="#tagset_converter_new_identity_converter">7.15.4. tagset_converter::new_identity_converter()</a>
      </li>
      <li><a href="#tagset_converter_new_pdt_to_conll2009_converter">7.15.5. tagset_converter::new_pdt_to_conll2009_converter()</a>
      </li>
      <li><a href="#tagset_converter_new_strip_lemma_comment_converter">7.15.6. tagset_converter::new_strip_lemma_comment_converter()</a>
      </li>
      <li><a href="#tagset_converter_new_strip_lemma_id_converter">7.15.7. tagset_converter::new_strip_lemma_id_converter()</a>
      </li>
      </ul>
    </li>
    <li><a href="#cpp_bindings_api">7.16. C++ Bindings API</a>
      <ul>
      <li><a href="#bindings_helper_structures">7.16.1. Helper Structures</a>
      </li>
      <li><a href="#bindings_main_classes">7.16.2. Main Classes</a>
      </li>
      </ul>
    </li>
    <li><a href="#csharp_bindings">7.17. C# Bindings</a>
    </li>
    <li><a href="#java_bindings">7.18. Java Bindings</a>
    </li>
    <li><a href="#perl_bindings">7.19. Perl Bindings</a>
    </li>
    <li><a href="#python_bindings">7.20. Python Bindings</a>
    </li>
    </ul>
  </li>
  <li><a href="#contact">Contact</a>
  </li>
  <li><a href="#morphodita_acknowledgements">Acknowledgements</a>
    <ul>
    <li><a href="#publications">9.1. Publications</a>
    </li>
    <li><a href="#bibtex_for_referencing">9.2. Bibtex for Referencing</a>
    </li>
    <li><a href="#persistent_identifier">9.3. Persistent Identifier</a>
    </li>
    </ul>
  </li>
  </ol>

</div>
<div class="body" ID="body">

<a id="introduction" name="introduction"></a>
<h1>1. Introduction</h1>

<p>
MorphoDiTa: Morphological Dictionary and Tagger is an open-source tool for
morphological analysis of natural language texts. It performs morphological
analysis, morphological generation, tagging and tokenization and is distributed
as a standalone tool or a library, along with trained linguistic models. In the
Czech language, MorphoDiTa achieves state-of-the-art results with a throughput
around 10-200K words per second. MorphoDiTa is a free software under
<a href="http://www.mozilla.org/MPL/2.0/">Mozilla Public License 2.0</a> and the linguistic models
are free for non-commercial use and distributed under
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a> license, although for some
models the original data used to create the model may impose additional
licensing conditions. MorphoDiTa is versioned using <a href="http://semver.org/">Semantic Versioning</a>.
</p>
<p>
Copyright 2014 by Institute of Formal and Applied Linguistics, Faculty of
Mathematics and Physics, Charles University in Prague, Czech Republic.
</p>

<a id="online" name="online"></a>
<h1>2. Online Web Application and Web Service</h1>

<p>
MorphoDiTa Web Application is available at <a href="http://lindat.mff.cuni.cz/services/morphodita/">http://lindat.mff.cuni.cz/services/morphodita/</a>
using <a href="http://lindat.cz">LINDAT/CLARIN infrastructure</a>.
</p>
<p>
MorphoDiTa REST Web Service is also available, with the API documentation available at
<a href="http://lindat.mff.cuni.cz/services/morphodita/api-reference.php">http://lindat.mff.cuni.cz/services/morphodita/api-reference.php</a>.
</p>

<a id="release" name="release"></a>
<h1>3. Release</h1>

<a id="download" name="download"></a>
<h2>3.1. Download</h2>

<p>
MorphoDiTa releases are available on <a href="http://github.com/ufal/morphodita">GitHub</a>, both as
source code and as a pre-compiled binary package. The binary package contains Linux,
Windows and OS X binaries, Java bindings binary, C# bindings binary, and source
code of MorphoDiTa and all language bindings). While the binary
packages do not contain compiled Python or Perl bindings, packages for those
languages are available in standard package repositories,
i.e. on <a href="https://pypi.python.org/pypi/ufal.morphodita/">PyPI</a>
and <a href="https://metacpan.org/pod/Ufal::MorphoDiTa">CPAN</a>.
</p>

<ul>
<li><a href="http://github.com/ufal/morphodita/releases/latest">Latest release</a>
</li>
<li><a href="http://github.com/ufal/morphodita/releases">All releases</a>, <a href="https://github.com/ufal/morphodita/blob/master/CHANGES">Changelog</a>
</li>
</ul>

<a id="language_models" name="language_models"></a>
<h3>3.1.1. Language Models</h3>

<p>
To use MorphoDiTa, a language model is needed. The language models are available
from <a href="http://www.lindat.cz">LINDAT/CLARIN</a> infrastructure and described further
in the
<a href="#users_manual">MorphoDiTa User's Manual</a>.
Currently the following language models are available:
</p>

<ul>
<li>Czech MorfFlex2+PDT-C: <a href="http://hdl.handle.net/11234/1-4794">czech-morfflex2.0-pdtc1.0-220710</a> (requires MorphoDiTa 1.9, <a href="http://ufal.mff.cuni.cz/morphodita/users-manual#czech-morfflex2-pdtc">documentation</a>)
</li>
<li>Czech MorfFlex+PDT: <a href="http://hdl.handle.net/11234/1-1836">czech-morfflex-pdt-161115</a> (requires MorphoDiTa 1.9, <a href="http://ufal.mff.cuni.cz/morphodita/users-manual#czech-morfflex-pdt">documentation</a>); older versions: <a href="http://hdl.handle.net/11234/1-1674">czech-morfflex-pdt-160310</a> (<a href="http://ufal.mff.cuni.cz/morphodita/users-manual#czech-morfflex-pdt_changes">documentation</a>), <a href="http://hdl.handle.net/11858/00-097C-0000-0023-68D8-1">czech-morfflex-pdt-131112</a> (<a href="http://ufal.mff.cuni.cz/morphodita/users-manual#czech-morfflex-pdt_changes">documentation</a>)
</li>
<li>Slovak MorfFlex+PDT: <a href="http://hdl.handle.net/11234/1-3278">slovak-morfflex-pdt-170914</a> (requires MorphoDiTa 1.9, <a href="http://ufal.mff.cuni.cz/morphodita/users-manual#slovak-morfflex-pdt">documentation</a>)
</li>
<li>English Morphium+WSJ: <a href="http://hdl.handle.net/11858/00-097C-0000-0023-68D9-0">english-morphium-wsj-140407</a> (<a href="http://ufal.mff.cuni.cz/morphodita/users-manual#english-morphium-wsj">documentation</a>)
</li>
</ul>

<a id="license" name="license"></a>
<h2>3.2. License</h2>

<p>
MorphoDiTa is an open-source project and is freely available for non-commercial
purposes. The library is distributed under
<a href="http://www.mozilla.org/MPL/2.0/">Mozilla Public License 2.0</a> and the associated models and data
under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a>, although
for some models the original data used to create the model may impose
additional licensing conditions.
</p>
<p>
If you use this tool for scientific work, please give credit to us by
referencing <a href="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa website</a> and
<a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Straková et al. 2014</a>.
</p>

<a id="instalation" name="instalation"></a>
<h1>4. MorphoDiTa Installation</h1>

<p>
MorphoDiTa releases are available on <a href="http://github.com/ufal/morphodita">GitHub</a>, either as
a pre-compiled binary package, or source code only. The binary package contains Linux,
Windows and OS X binaries, Java bindings binary, C# bindings binary, and source
code of MorphoDiTa and all language bindings. While the binary
packages do not contain compiled Python or Perl bindings, packages for those
languages are available in standard package repositories, i.e. on PyPI and CPAN.
</p>
<p>
To use MorphoDiTa, a language model is needed.
<a href="http://ufal.mff.cuni.cz/morphodita#language_models">Here is a list of available language models</a>.
</p>
<p>
If you want to compile MorphoDiTa manually, sources are available on on
<a href="http://github.com/ufal/morphodita">GitHub</a>, both in the
<a href="http://github.com/ufal/morphodita/releases">pre-compiled binary package releases</a>
and in the repository itself.
</p>

<a id="requirements" name="requirements"></a>
<h2>4.1. Requirements</h2>

<ul>
<li><code>G++ 4.9</code> or newer, <code>clang 3.2</code> or newer, Visual C++ 2015 or newer
</li>
<li><code>make</code>
</li>
<li><code>SWIG</code> or newer for language bindings other than <code>C++</code>
</li>
</ul>

<a id="compilation" name="compilation"></a>
<h2>4.2. Compilation</h2>

<p>
To compile MorphoDiTa, run <code>make</code> in the <code>src</code> directory.
</p>
<p style="margin-bottom:0">
Make targets and options:
</p>
<ul style="margin-top:0">
<li><code>exe</code>: compile the binaries (default)
</li>
<li><code>server</code>: compile the REST server
</li>
<li><code>tools</code>: compile various tools
</li>
<li><code>lib</code>: compile MorphoDiTa library (decoding only)
</li>
<li><code>BITS=32</code> or <code>BITS=64</code>: compile for specified 32-bit or 64-bit architecture instead of the default one
</li>
<li><code>MODE=release</code>: create release build which statically links the C++ runtime and uses LTO
</li>
<li><code>MODE=debug</code>: create debug build
</li>
<li><code>MODE=profile</code>: create profile build
</li>
</ul>

<a id="compilation_platforms" name="compilation_platforms"></a>
<h3>4.2.1. Platforms</h3>

<p style="margin-bottom:0">
Platform can be selected using one of the following options:
</p>
<ul style="margin-top:0">
<li><code>PLATFORM=linux</code>, <code>PLATFORM=linux-gcc</code>: gcc compiler on Linux operating system, default on Linux
</li>
<li><code>PLATFORM=linux-clang</code>: clang compiler on Linux, must be selected manually
</li>
<li><code>PLATFORM=macos</code>, <code>PLATFORM=macos-clang</code>: clang compiler on OS X, default on OS X; <code>BITS=32+64</code> enables multiarch build
</li>
<li><code>PLATFORM=win</code>, <code>PLATFORM=win-gcc</code>: gcc compiler on Windows (TDM-GCC is well tested), default on Windows
</li>
<li><code>PLATFORM=win-vs</code>: Visual C++ 2015 compiler on Windows, must be selected manually; note that the
  <code>cl.exe</code> compiler must be already present in <code>PATH</code> and corresponding <code>BITS=32</code> or <code>BITS=64</code>
  must be specified
</li>
</ul>

<p>
Either POSIX shell or Windows CMD can be used as shell, it is detected automatically.
</p>

<a id="compilation_further_details" name="compilation_further_details"></a>
<h3>4.2.2. Further Details</h3>

<p>
MorphoDiTa uses <a href="http://github.com/ufal/cpp_builtem">C++ BuilTem system</a>,
please refer to its manual if interested in all supported options.
</p>

<a id="other_language_bindings" name="other_language_bindings"></a>
<h2>4.3. Other language bindings</h2>

<a id="csharp_installation" name="csharp_installation"></a>
<h3>4.3.1. C#</h3>

<p>
Binary C# bindings are available in MorphoDiTa binary packages.
</p>
<p>
To compile C# bindings manually, run <code>make</code> in the <code>bindings/csharp</code>
directory, optionally with the options descriged in MorphoDiTa Installation.
</p>

<a id="java_installation" name="java_installation"></a>
<h3>4.3.2. Java</h3>

<p>
Binary Java bindings are available in MorphoDiTa binary packages.
</p>
<p>
To compile Java bindings manually, run <code>make</code> in the <code>bindings/java</code>
directory, optionally with the options descriged in MorphoDiTa Installation.
Java 6 and newer is supported.
</p>
<p style="margin-bottom:0">
The Java installation specified in the environment variable <code>JAVA_HOME</code> is
used.  If the environment variable does not exist, the <code>JAVA_HOME</code> can be
specified using
</p>
<pre style="margin-top:0">
make JAVA_HOME=path_to_Java_installation
</pre>

<a id="perl_installation" name="perl_installation"></a>
<h3>4.3.3. Perl</h3>

<p>
The Perl bindings are available as <code>Ufal-MorphoDiTa</code> package on CPAN.
</p>
<p>
To compile Perl bindings manually, run <code>make</code> in the <code>bindings/perl</code>
directory, optionally with the options descriged in MorphoDiTa Installation.
Perl 5.10 and later is supported.
</p>
<p style="margin-bottom:0">
Path to the include headers of the required Perl version must be specified
in the <code>PERL_INCLUDE</code> variable using
</p>
<pre style="margin-top:0">
make PERL_INCLUDE=path_to_Perl_includes
</pre>

<a id="python_installation" name="python_installation"></a>
<h3>4.3.4. Python</h3>

<p>
The Python bindings are available as <code>ufal.morphodita</code> package on PyPI.
</p>
<p>
To compile Python bindings manually, run <code>make</code> in the <code>bindings/python</code>
directory, optionally with options descriged in MorphoDiTa Installation.
Python 3+ is supported.
</p>
<p style="margin-bottom:0">
Path to the include headers of the required Python version must be specified
in the <code>PYTHON_INCLUDE</code> variable using
</p>
<pre style="margin-top:0">
make PYTHON_INCLUDE=path_to_Python_includes
</pre>

<a id="users_manual" name="users_manual"></a>
<h1>5. MorphoDiTa User's Manual</h1>

<p>
In a natural language text, the task of morphological analysis is to assign for
each token (word) in a sentence its lemma (cannonical form) and
a part-of-speech tag (POS tag). This is usually achieved in two steps:
a morphological dictionary looks up all possible lemmas and POS tags for each
word, and subsequently, a morphological tagger picks for each word the best
lemma-POS tag candidate. The second task is called a disambiguation.
</p>
<p>
MorphoDiTa also performs these two steps of morphological analysis: It first
outputs all possible pairs of lemma and POS tag for each token. Consequently,
the optimal combination of lemmas and POS tags is selected for the words in
a sentence using an algorithm described in
<a href="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Spoustová et al. 2009</a>.
</p>
<p>
Like any supervised machine learning tool, MorphoDiTa needs a trained linguistic model.
This section describes the available language models and also the commandline
tools and interfaces. The C++ library is described elsewhere, either in
MorphoDiTa API Tutorial or in MorphoDiTa API Reference.
</p>

<a id="czech-morfflex2-pdtc" name="czech-morfflex2-pdtc"></a>
<h2>5.1. Czech MorfFlex2+PDT-C Models</h2>

<p>
Czech models are distributed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a> licence.
The Czech morphology uses the
<a href="http://hdl.handle.net/11234/1-3186">MorfFlex CZ 2.0</a>
Czech morphological dictionary and the Czech tagger is trained on
<a href="http://hdl.handle.net/11234/1-3185">PDT-C 1.0</a>. The morpholodical derivator
is uses the <a href="http://hdl.handle.net/11234/1-3765">DeriNet 2.1</a>.
Czech models work in MorphoDiTa version 1.9 or later.
</p>
<p>
Apart from MorfFlex CZ dictionary, a prefix guesser and statistical guesser
are implemented and can be optionally used when performing morphological analysis.
</p>

<a id="czech-morfflex2-pdtc_download" name="czech-morfflex2-pdtc_download"></a>
<h3>5.1.1. Download</h3>

<p>
The latest version 220710 of the Czech MorfFlex+PDT models can be downloaded
from <a href="http://hdl.handle.net/11234/1-4794">LINDAT/CLARIN repository</a>.
</p>

<a id="czech-morfflex2-pdtc_acknowledgements" name="czech-morfflex2-pdtc_acknowledgements"></a>
<h3>5.1.2. Acknowledgements</h3>

<p>
This work has been has been supported by the LINDAT/CLARIAH-CZ project funded
by Ministry of Education, Youth and Sports of the Czech Republic (project
<i>LM2018101</i>).
</p>

<a id="czech-morfflex2-pdtc_publications" name="czech-morfflex2-pdtc_publications"></a>
<h4>5.1.2.1. Publications</h4>

<ul>
<li>(Straková et al., 2014) Straková Jana, Straka Milan and Hajič Jan. <i><a href="https://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition</a>.</i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
<p></p>
</li>
<li>(Jonáš Vidra et al., 2019) Jonáš Vidra, Zdeněk Žabokrtský, Magda Ševčíková, Lukáš Kyjánek. <i>Towards an All-in-One Word-Formation Resource.</i> In Proceedings of the Second Workshop on Resources and Tools for Derivational Morphology (DeriMo 2019). Prague, 2019, pp. 81-89.
<p></p>
</li>
<li>(Jan Hajič et al., 2020) Jan Hajič, Eduard Bejček, Jaroslava Hlavacova, Marie Mikulová, Milan Straka, Jan Štěpánek, and Barbora Štěpánková. <i><a href="https://aclanthology.org/2020.lrec-1.641.pdf">Prague Dependency Treebank - Consolidated 1.0</a>.</i> In Proceedings of the 12th Language Resources and Evaluation Conference, pages 5208–5218, Marseille, France. European Language Resources Association.
<p></p>
</li>
<li>(Marie Mikulová et al., 2022) Mikulová Marie, Hajič Jan, Hana Jiří, Hanová Hana, Hlaváčová Jaroslava, Jeřábek Emil, Štěpánková Barbora, Vidová Hladká Barbora, Zeman Daniel. <i><a href="https://ufal.mff.cuni.cz/techrep/tr64.pdf">Manual for Morphological Annotation, Revision for the Prague Dependency Treebank - Consolidated 2020 release</a>.</i> Technical report no. TR-2020-64, Institute of Formal and Applied Linguistics, Charles University, Prague, Czechia, 2020.
</li>
</ul>

<a id="czech_morfflex2_system" name="czech_morfflex2_system"></a>
<h3>5.1.3. MorfFlex CZ 2.0 Morphological System</h3>

<p>
The MorfFlex CZ 2.0 uses a so-called <i>PDT-C tag set</i>, which is an evolution
of the original <i>PDT tag set</i> devised by Jan Hajič
(<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>).
The tags are positional with 15 positions corresponding to part of speech,
detailed part of speech, gender, number, case, etc. (e.g. <code>NNFS1-----A----</code>).
Different meanings of same lemmas are distinguished and additional comments can
be provided for every lemma meaning. The lemma itself without the comments and
meaning specification is called a <i>raw lemma</i>. The following examples
illustrate this:
</p>

<ul>
<li><code>Japonsko_;G</code> (raw lemma: <code>Japonsko</code>)
</li>
<li><code>se_^(zvr._zájmeno/částice)</code> (raw lemma: <code>se</code>)
</li>
<li><code>tvořit_:T</code> (raw lemma: <code>tvořit</code>)
</li>
</ul>

<p>
The complete reference can be found in the
<a href="https://ufal.mff.cuni.cz/techrep/tr64.pdf">Manual for Morphological Annotation, Revision for the Prague Dependency Treebank - Consolidated 2020 release</a>.
</p>

<a id="czech-morfflex2-pdtc_split" name="czech-morfflex2-pdtc_split"></a>
<h3>5.1.4. PDT-C 1.0 Train/Dev/Test Split</h3>

<p>
The PDT-C corpus consists of four datasets, but some of them do not have
an official train/dev/test split. We therefore used the following split:
</p>

<ul>
<li>PDT dataset is already split into train, dev (<code>dtest</code>), and test (<code>etest</code>).
</li>
<li>PCEDT dataset is a translated version of the Wall Street Journal, so we used
  the usual split into train (sections 0-18), dev (sections 19-21), and test
  (sections 22-24).
</li>
<li>PDTSC and FAUST datasets have no split, so we split it into dev (documents
  with identifiers ending with 6), test (documents with identifiers ending with 7),
  and train (all the remaining documents).
</li>
</ul>

<a id="czech-morfflex2-pdtc_variants" name="czech-morfflex2-pdtc_variants"></a>
<h3>5.1.5. Model Variants</h3>

<p>
Apart from the primary model, which predicts all the 15 tag positions and processed
texts with diacritics, we also provide several variants:
</p>

<ul>
<li><code>pos_only</code>: Instead of all 15 tag positions, the model predicts only the first 2,
  which contain the coarse and detailed POS, plus the full lemma, while being
  circa 15 times faster than the primary model.
<p></p>
</li>
<li><code>no_dia</code>, <code>no_dia-pos_only</code>: The forms (during morphological analysis,
  generation, and tagging) have the diacritical marks stripped; however, the
  lemmas do include them. Useful for processing texts without diacritics.
</li>
</ul>

<a id="czech-morfflex2-pdtc_performance" name="czech-morfflex2-pdtc_performance"></a>
<h3>5.1.6. Model Performance</h3>

<table border="1">
<tr>
<th></th>
<th colspan="5">Tags</th>
<th colspan="5">Lemmas</th>
<th colspan="2">Performance</th>
</tr>
<tr>
<th>Model</th>
<th>PDT</th>
<th>PCEDT</th>
<th>PDTSC</th>
<th>Faust</th>
<th>MacroAvg</th>
<th>PDT</th>
<th>PCEDT</th>
<th>PDTSC</th>
<th>Faust</th>
<th>MacroAvg</th>
<th>Speed</th>
<th>Size</th>
</tr>
<tr>
<td><code>czech-morfflex2.0-pdtc1.0-220710</code></td>
<td>96.29</td>
<td>97.00</td>
<td>96.90</td>
<td>94.87</td>
<td>96.27</td>
<td>98.69</td>
<td>98.85</td>
<td>98.18</td>
<td>97.53</td>
<td>98.31</td>
<td align="right">19k toks/s</td>
<td align="right">24.4MB</td>
</tr>
<tr>
<td><code>czech-morfflex2.0-pdtc1.0-220710-pos_only</code></td>
<td>98.99</td>
<td>99.12</td>
<td>98.45</td>
<td>97.85</td>
<td>98.60</td>
<td>98.50</td>
<td>98.63</td>
<td>98.09</td>
<td>97.05</td>
<td>98.07</td>
<td align="right">253k toks/s</td>
<td align="right">9.5MB</td>
</tr>
<tr>
<td><code>czech-morfflex2.0-pdtc1.0-220710-no_dia</code></td>
<td>95.57</td>
<td>96.13</td>
<td>96.40</td>
<td>93.46</td>
<td>95.39</td>
<td>97.88</td>
<td>98.20</td>
<td>97.67</td>
<td>96.57</td>
<td>97.58</td>
<td align="right">11k toks/s</td>
<td align="right">30.4MB</td>
</tr>
<tr>
<td><code>czech-morfflex2.0-pdtc1.0-220710-no_dia-pos_only</code></td>
<td>98.55</td>
<td>98.73</td>
<td>98.07</td>
<td>97.31</td>
<td>98.17</td>
<td>97.60</td>
<td>97.85</td>
<td>97.52</td>
<td>95.98</td>
<td>97.24</td>
<td align="right">177k toks/s</td>
<td align="right">14.5MB</td>
</tr>
</table>

<a id="czech-morfflex-pdt" name="czech-morfflex-pdt"></a>
<h2>5.2. Czech MorfFlex+PDT Models</h2>

<p>
Czech models are distributed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a> licence.
The Czech morphology uses the
<a href="http://hdl.handle.net/11234/1-1834">MorfFlex CZ 161115</a>
Czech morphological dictionary and the Czech tagger is trained on
<a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a>. The morpholodical derivator
is uses the <a href="http://ufal.mff.cuni.cz/derinet">DeriNet 1.2</a>.
Czech models work in MorphoDiTa version 1.9 or later.
</p>
<p>
Apart from MorfFlex CZ dictionary, a prefix guesser and statistical guesser
are implemented and can be optionally used when performing morphological analysis.
</p>
<p>
Czech models are versioned according to the version of the MorfFlex CZ
morphological dictionary used, the version format is <code>YYMMDD</code>, where <code>YY</code>,
<code>MM</code> and <code>DD</code> are two-digit representation of year, month and day,
respectively. The latest version is 161115.
</p>
<p>
Compared to Featurama <a href="http://sourceforge.net/projects/featurama/">http://sourceforge.net/projects/featurama/</a>
(state-of-the-art Czech tagger implementation), the models are 5 times faster
and 10 times smaller.
</p>

<a id="czech-morfflex-pdt_download" name="czech-morfflex-pdt_download"></a>
<h3>5.2.1. Download</h3>

<p>
The latest version 161115 of the Czech MorfFlex+PDT models can be downloaded
from <a href="http://hdl.handle.net/11234/1-1836">LINDAT/CLARIN repository</a>.
</p>

<a id="czech-morfflex-pdt_download_previous" name="czech-morfflex-pdt_download_previous"></a>
<h4>5.2.1.1. Previous Versions</h4>

<ul>
<li>Version 160310 of the Czech MorphoDiTa models can be downloaded
  from <a href="http://hdl.handle.net/11234/1-1674">LINDAT/CLARIN repository</a>.
</li>
<li>Version 131112 of the Czech MorphoDiTa models can be downloaded
  from <a href="http://hdl.handle.net/11858/00-097C-0000-0023-68D8-1">LINDAT/CLARIN repository</a>.
</li>
</ul>

<a id="czech-morfflex-pdt_acknowledgements" name="czech-morfflex-pdt_acknowledgements"></a>
<h3>5.2.2. Acknowledgements</h3>

<p>
This work has been using language resources developed and/or stored and/or
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <i>LM2010013</i>).
</p>
<p>
The Czech morphological system was devised by Jan Hajič.
</p>
<p>
The MorfFlex CZ dictionary was created by Jan Hajič and Jaroslava Hlaváčová.
</p>
<p>
The morphological guesser research was supported by the projects
<i>1ET101120503</i> and <i>1ET101120413</i> of Academy of Sciences of the Czech
Republic and <i>100008/2008</i> of Charles University Grant Agency. The research
was performed by Jan Hajič, Jaroslava Hlaváčová and David Kolovratník.
</p>
<p>
The tagger algorithm and feature set research was supported by the projects
<i>MSM0021620838</i> and <i>LC536</i> of Ministry of Education, Youth and Sports of the Czech Republic,
<i>GA405/09/0278</i> of the Grant Agency of the Czech Republic and <i>1ET101120503</i> of
Academy of Sciences of the Czech Republic. The research was performed by
Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab and Miroslav Spousta.
</p>
<p>
The tagger is trained on morphological layer of Prague Dependency Treebank PDT
3.0, which was supported by the projects <i>LM2010013</i>, <i>LC536</i>,
<i>LN00A063</i> and <i>MSM0021620838</i> of Ministry of Education, Youth and Sports
of the Czech Republic, and developed by Martin Buben, Jan Hajič, Jiří Hana,
Hana Hanová, Barbora Hladká, Emil Jeřábek, Lenka Kebortová, Kristýna Kupková,
Pavel Květoň, Jiří Mírovský, Andrea Pfimpfrová, Jan Štěpánek and Daniel Zeman.
</p>
<p>
The morphological derivator is based on DeriNet, which was supported by the
Grant No. 16-18177S of the Grant Agency of the Czech Republic and uses
language resources developed, stored, and distributed by the LINDAT/CLARIN
project of the Ministry of Education, Youth and Sports of the Czech Republic
(project LM2015071).
</p>

<a id="czech-morfflex-pdt_publications" name="czech-morfflex-pdt_publications"></a>
<h4>5.2.2.1. Publications</h4>

<ul>
<li>(Hajič 2004) Jan Hajič. <i><a href="http://books.google.cz/books?id=sB63AAAACAAJ">Disambiguation of Rich Inflection: Computational Morphology of Czech.</a></i> Karolinum Press (2004).
<p></p>
</li>
<li>Hlaváčová Jaroslava, Kolovratník David. <i>Morfologie češtiny znovu a lépe.</i> In Informačné Technológie - Aplikácie a Teória. Zborník príspevkov, ITAT 2008.  Seňa, Slovakia: PONT s.r.o., 2008, pp. 43-47.
<p></p>
</li>
<li>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <i><a href="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</a></i> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
<p></p>
</li>
<li>(Straková et al. 2014) Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
<p></p>
</li>
<li>(Žabokrtský et al. 2016) Zdeněk Žabokrtský, Magda Ševčíková, Milan Straka, Jonáš Vidra and Adéla Limburská. <i>Merging Data Resources for Inflectional and Derivational Morphology in Czech.</i> In Proceedings of the Tenth International Conference on Language Resources and Evaluation (LREC 2016), Portorož, Slovenia, May 2016.
</li>
</ul>

<a id="czech_morphological_system" name="czech_morphological_system"></a>
<h3>5.2.3. Czech Morphological System</h3>

<p>
In the Czech language, MorphoDiTa uses Czech morphological system by
Jan Hajič (<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>).
In this system, which we call <i>PDT tag set</i>, the tags are positional with 15
positions corresponding to part of speech, detailed part of speech, gender,
number, case, etc. (e.g. <code>NNFS1-----A----</code>).  Different meanings of same
lemmas are distinguished and additional comments can be provided for every
lemma meaning. The lemma itself without the comments and meaning specification
is called a <i>raw lemma</i>. The following examples illustrate this:
</p>

<ul>
<li><code>Japonsko_;G</code> (raw lemma: <code>Japonsko</code>)
</li>
<li><code>se_^(zvr._zájmeno/částice)</code> (raw lemma: <code>se</code>)
</li>
<li><code>tvořit_:T</code> (raw lemma: <code>tvořit</code>)
</li>
</ul>

<p>
For a more detailed reference about the Czech morphology, please see
<a href="http://ufal.mff.cuni.cz/pdt2.0/doc/manuals/en/m-layer/html/ch02.html">Lemma and Tag Structure in PDT 2.0</a>.
</p>

<a id="czech-morfflex-pdt_model" name="czech-morfflex-pdt_model"></a>
<h3>5.2.4. Main Czech Model</h3>

<p>
The main Czech model contains the following files:
</p>

<dl>
<dt><code>czech-morfflex-161115.dict</code></dt><dd>
  Morphological dictionary based on the Jan Hajič's (<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>)
  system with PDT tag set created from
  <a href="http://hdl.handle.net/11234/1-1834">MorfFlex CZ 161115</a> morphological dictionary
  and <a href="http://ufal.mff.cuni.cz/derinet">DeriNet 1.2</a>.
<p></p>
</dd>
<dt><code>czech-morfflex-pdt-161115.tagger</code></dt><dd>
  Tagger trained on the training portion
  of <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> using the <code>neopren</code> feature
  set. It contains the <code>czech-morfflex-161115.dict</code> morphological dictionary.
  and reaches 95.55% tag
  accuracy, 97.86% lemma accuracy and 95.06% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (whose morphological tags and lemmas
  were remapped using the <code>czech-morfflex-161115.dict</code> dictionary). Model speed: ~15k words/s,
  model size: 18MB.
</dd>
</dl>

<a id="czech-morfflex-pdt_pos_variant" name="czech-morfflex-pdt_pos_variant"></a>
<h3>5.2.5. Part of Speech Only Variant</h3>

<p>
The PDT tag set used by the main Czech model is very fine-grained. In many
situations, only the part of speech tags would be sufficient. Therefore, we
provide a variant of the model, denoted as <code>pos_only</code>, where only the first
two characters of the fifteen-letter tags are used, representing the part of
speech and detailed part of speech, respectively. There are 67 such two-letter tags.
</p>

<dl>
<dt><code>czech-morfflex-161115-pos_only.dict</code></dt><dd>
  Morphological dictionary based on the Jan Hajič's (<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>)
  system created from
  <a href="http://hdl.handle.net/11234/1-1834">MorfFlex CZ 161115</a> morphological dictionary
  and <a href="http://ufal.mff.cuni.cz/derinet">DeriNet 1.2</a>.
  Only first two tag characters of PDT tag set are used.
<p></p>
</dd>
<dt><code>czech-morfflex-pdt-161115-pos_only.tagger</code></dt><dd>
  Very fast tagger trained on the training portion of
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> using the <code>neopren</code> feature
  set. It contains the <code>czech-morfflex-161115-pos_only.dict</code> morphological dictionary
  and reaches 99.01% tag
  accuracy, 97.69% lemma accuracy and 97.66% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (which morphological tags and lemmas
  were remapped using the <code>czech-morfflex-161115-pos_only.dict</code> dictionary).
  Model speed: ~250k words/s, model size: 5MB.
</dd>
</dl>

<a id="czech-morfflex-pdt_no_dia_variant" name="czech-morfflex-pdt_no_dia_variant"></a>
<h3>5.2.6. No Diacritical Marks Variant</h3>

<p>
Sometimes the text to be analyzed does not contain diacritical marks.
We therefore provide variants of the morphological dictionary and tagger
for this purpose &ndash; morphological analysis, morphological generation and
tagging employ forms without diacritical marks. Note that the lemmas do
have diacritical marks.
</p>
<p>
We provide the <code>no_dia</code> variants for all four models described above:
</p>

<dl>
<dt><code>czech-morfflex-161115-no_dia.dict</code></dt><dd>
  No diacritical marks variant of <code>czech-morfflex-161115.dict</code>.
<p></p>
</dd>
<dt><code>czech-morfflex-pdt-161115-no_dia.tagger</code></dt><dd>
  No diacritical marks variant of <code>czech-morfflex-161115.tagger</code>.
  It reaches 94.69% tag
  accuracy, 97.06% lemma accuracy and 93.84% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (which morphological tags and lemmas
  were remapped using the <code>czech-morfflex-161115-no_dia.dict</code> dictionary)
  with diacritical marks removed.
  Model speed: ~7.5k words/s, model size: 22MB.
<p></p>
</dd>
<dt><code>czech-morfflex-161115-no_dia-pos_only.dict</code></dt><dd>
  No diacritical marks variant of <code>czech-morfflex-161115-pos_only.dict</code>.
<p></p>
</dd>
<dt><code>czech-morfflex-pdt-161115-no_dia-pos_only.tagger</code></dt><dd>
  No diacritical marks variant of <code>czech-morfflex-161115-pos_only.tagger</code>.
  It reaches 98.55% tag
  accuracy, 97.07% lemma accuracy and 97.02% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (which morphological tags and lemmas
  were remapped using the <code>czech-morfflex-161115-no_dia-pos_only.dict</code> dictionary)
  with diacritical marks removed.
  Model speed: ~125k words/s, model size: 11MB.
</dd>
</dl>

<a id="czech-morfflex-pdt_raw_lemmas_variant" name="czech-morfflex-pdt_raw_lemmas_variant"></a>
<h3>5.2.7. Models with Raw Lemmas</h3>

<p>
The Czech morphological system distinguish different meanings of same lemmas by
numbering the lemmas with multiple meanings and supplying additional comments
for every lemma meaning, as described and demonstrated in
<a href="#czech_morphological_system">Czech Morphological System</a>. Sometimes this may be
undesirable, for example when comparing to systems which do not use the
<a href="http://hdl.handle.net/11234/1-1834">MorfFlex CZ</a> morphological dictionary.
</p>
<p>
To obtain lemmas without any additional information (<i>raw lemmas</i> in terms of
MorphoDiTa API), use <code>strip_lemma_id</code> tag set converter.  Previously,
specific dictionary and tagger model variants were provided, which is not needed
anymore.
</p>

<a id="czech-morfflex-pdt_changes" name="czech-morfflex-pdt_changes"></a>
<h3>5.2.8. Czech Model History</h3>

<dl>
<dt><code>czech-morfflex-161115</code> and <code>czech-morfflex-pdt-161115</code> (require MorphoDiTa 1.9 or later)</dt><dd>
  Trained on <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> using <a href="http://hdl.handle.net/11234/1-1834">MorfFlex CZ 161115</a>
  and <a href="http://ufal.mff.cuni.cz/derinet">DeriNet 1.2</a>,
  variants: Part of Speech Only, No Diacritical Marks. <a href="http://hdl.handle.net/11234/1-1836">Download from LINDAT/CLARIN repository</a>.
<p></p>
</dd>
<dt><code>czech-morfflex-160310</code> and <code>czech-morfflex-pdt-160310</code> (require MorphoDiTa 1.0 or later)</dt><dd>
  Trained on <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> using <a href="http://hdl.handle.net/11234/1-1673">MorfFlex CZ 160310</a>,
  variants: Part of Speech Only, No Diacritical Marks. <a href="http://hdl.handle.net/11234/1-1674">Download from LINDAT/CLARIN repository</a>.
<p></p>
</dd>
<dt><code>czech-morfflex-131112</code> and <code>czech-morfflex-pdt-131112</code> (require MorphoDiTa 1.0 or later)</dt><dd>
  Trained on <a href="http://ufal.mff.cuni.cz/pdt2.5">PDT 2.5</a> using <a href="http://hdl.handle.net/11858/00-097C-0000-0015-A780-9">MorfFlex CZ 131112</a>,
  variants Part of Speech Only, Raw Lemmas. <a href="http://hdl.handle.net/11858/00-097C-0000-0023-68D8-1">Download from LINDAT/CLARIN repository</a>.
</dd>
</dl>

<a id="slovak-morfflex-pdt" name="slovak-morfflex-pdt"></a>
<h2>5.3. Slovak MorfFlex+PDT Models</h2>

<p>
Slovak models are distributed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA</a> licence.
The Slovak morphology uses the
<a href="http://hdl.handle.net/11234/1-3277">MorfFlex SK 170914</a>
Slovak morphological dictionary and the Slovak tagger is trained on
automatically translated <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a>.
Slovak models work in MorphoDiTa version 1.9 or later.
</p>
<p>
Apart from MorfFlex SK dictionary, a statistical guesser is implemented and can
be optionally used when performing morphological analysis.
</p>
<p>
Slovak models are versioned according to the version of the MorfFlex SK
morphological dictionary used, the version format is <code>YYMMDD</code>, where <code>YY</code>,
<code>MM</code> and <code>DD</code> are two-digit representation of year, month and day,
respectively. The latest version is 170914.
</p>

<a id="slovak-morfflex-pdt_download" name="slovak-morfflex-pdt_download"></a>
<h3>5.3.1. Download</h3>

<p>
The latest version 170914 of the Slovak MorfFlex+PDT models can be downloaded
from <a href="http://hdl.handle.net/11234/1-3278">LINDAT/CLARIN repository</a>.
</p>

<a id="slovak-morfflex-pdt_acknowledgements" name="slovak-morfflex-pdt_acknowledgements"></a>
<h3>5.3.2. Acknowledgements</h3>

<p>
This work has also been supported by the LINDAT/CLARIAH-CZ Research
Infrastructure (<a href="https://lindat.cz">https://lindat.cz</a>), supported by the Ministry of Education,
Youth and Sports of the Czech Republic (Project No. <i>LM2018101</i>).
It has also been using language resources developed and stored and
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <i>LM2015071</i>).
</p>
<p>
The Czech morphological system was devised by Jan Hajič.
</p>
<p>
The MorfFlex SK dictionary was created by Jan Hajič and Jan Hric.
</p>
<p>
The tagger algorithm and feature set research was supported by the projects
<i>MSM0021620838</i> and <i>LC536</i> of Ministry of Education, Youth and Sports of the Czech Republic,
<i>GA405/09/0278</i> of the Grant Agency of the Czech Republic and <i>1ET101120503</i> of
Academy of Sciences of the Czech Republic. The research was performed by
Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab and Miroslav Spousta.
</p>
<p>
The tagger is trained on morphological layer of Prague Dependency Treebank PDT
3.0, which was supported by the projects <i>LM2010013</i>, <i>LC536</i>,
<i>LN00A063</i> and <i>MSM0021620838</i> of Ministry of Education, Youth and Sports
of the Czech Republic, and developed by Martin Buben, Jan Hajič, Jiří Hana,
Hana Hanová, Barbora Hladká, Emil Jeřábek, Lenka Kebortová, Kristýna Kupková,
Pavel Květoň, Jiří Mírovský, Andrea Pfimpfrová, Jan Štěpánek and Daniel Zeman.
</p>

<a id="slovak-morfflex-pdt_publications" name="slovak-morfflex-pdt_publications"></a>
<h4>5.3.2.1. Publications</h4>

<ul>
<li>(Hajič 2004) Jan Hajič. <i><a href="http://books.google.cz/books?id=sB63AAAACAAJ">Disambiguation of Rich Inflection: Computational Morphology of Czech.</a></i> Karolinum Press (2004).
<p></p>
</li>
<li>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <i><a href="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</a></i> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
<p></p>
</li>
<li>(Straková et al. 2014) Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
</li>
</ul>

<a id="slovak_morphological_system" name="slovak_morphological_system"></a>
<h3>5.3.3. Slovak Morphological System</h3>

<p>
In the Slovak language, MorphoDiTa uses the
<a href="#czech_morphological_system">same morphological system as Czech</a>.
</p>

<a id="slovak-morfflex-pdt_model" name="slovak-morfflex-pdt_model"></a>
<h3>5.3.4. Main Slovak Model</h3>

<p>
The main Slovak model contains the following files:
</p>

<dl>
<dt><code>slovak-morfflex-170914.dict</code></dt><dd>
  Morphological dictionary based on the Jan Hajič's (<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>)
  system with PDT tag set created from
  <a href="http://hdl.handle.net/11234/1-3277">MorfFlex SK 170914</a> morphological dictionary.
<p></p>
</dd>
<dt><code>slovak-morfflex-pdt-170914.tagger</code></dt><dd>
  Tagger trained on the training portion
  of automatically translated <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> using
  the <code>neopren</code> feature set. It contains the <code>slovak-morfflex-170914.dict</code>
  morphological dictionary. and reaches 92.8% tag accuracy, 96.3% lemma
  accuracy and 92.0% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (whose morphological tags and
  lemmas were remapped using the <code>slovak-morfflex-170914.dict</code> dictionary).
  Model speed: ~5k words/s, model size: 17MB.
</dd>
</dl>

<a id="slovak-morfflex-pdt_pos_variant" name="slovak-morfflex-pdt_pos_variant"></a>
<h3>5.3.5. Part of Speech Only Variant</h3>

<p>
The PDT tag set used by the main Slovak model is very fine-grained. In many
situations, only the part of speech tags would be sufficient. Therefore, we
provide a variant of the model, denoted as <code>pos_only</code>, where only the first
two characters of the fifteen-letter tags are used, representing the part of
speech and detailed part of speech, respectively. There are 67 such two-letter tags.
</p>

<dl>
<dt><code>slovak-morfflex-170914-pos_only.dict</code></dt><dd>
  A variant of `slovak-morfflex-170914.dict`, where only the first two tag
  characters are used.
<p></p>
</dd>
<dt><code>slovak-morfflex-pdt-170914-pos_only.tagger</code></dt><dd>
  Very fast variant of <code>slovak-morfflex-170914.tagger</code> predicting
  only two-character tags. It reaches 98.3% tag accuracy, 97.4% lemma
  accuracy and 96.8% overall accuracy on <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a>
  etest data (which morphological tags and lemmas were remapped using the
  <code>slovak-morfflex-170914-pos_only.dict</code> dictionary).
  Model speed: ~200k words/s, model size: 4MB.
</dd>
</dl>

<a id="slovak-morfflex-pdt_no_dia_variant" name="slovak-morfflex-pdt_no_dia_variant"></a>
<h3>5.3.6. No Diacritical Marks Variant</h3>

<p>
Sometimes the text to be analyzed does not contain diacritical marks.
We therefore provide variants of the morphological dictionary and tagger
for this purpose &ndash; morphological analysis, morphological generation and
tagging employ forms without diacritical marks. Note that the lemmas do
have diacritical marks.
</p>
<p>
We provide the <code>no_dia</code> variants for all four models described above:
</p>

<dl>
<dt><code>slovak-morfflex-170914-no_dia.dict</code></dt><dd>
  No diacritical marks variant of <code>slovak-morfflex-170914.dict</code>.
<p></p>
</dd>
<dt><code>slovak-morfflex-pdt-170914-no_dia.tagger</code></dt><dd>
  No diacritical marks variant of <code>slovak-morfflex-170914.tagger</code>.
  It reaches 91.4% tag
  accuracy, 92.8% lemma accuracy and 89.0% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (which morphological tags and lemmas
  were remapped using the <code>slovak-morfflex-170914-no_dia.dict</code> dictionary)
  with diacritical marks removed.
  Model speed: ~5k words/s, model size: 18MB.
<p></p>
</dd>
<dt><code>slovak-morfflex-170914-no_dia-pos_only.dict</code></dt><dd>
  No diacritical marks variant of <code>slovak-morfflex-170914-pos_only.dict</code>.
<p></p>
</dd>
<dt><code>slovak-morfflex-pdt-170914-no_dia-pos_only.tagger</code></dt><dd>
  No diacritical marks variant of <code>slovak-morfflex-170914-pos_only.tagger</code>.
  It reaches 97.5% tag
  accuracy, 93.9% lemma accuracy and 93.2% overall accuracy on
  <a href="http://ufal.mff.cuni.cz/pdt3.0">PDT 3.0</a> etest data (which morphological tags and lemmas
  were remapped using the <code>slovak-morfflex-170914-no_dia-pos_only.dict</code> dictionary)
  with diacritical marks removed.
  Model speed: ~200k words/s, model size: 7MB.
</dd>
</dl>

<a id="english-morphium-wsj" name="english-morphium-wsj"></a>
<h2>5.4. English Morphium+WSJ Models</h2>

<p style="margin-bottom:0">
English models are created using the following data:
</p>
<ul style="margin-top:0">
<li><i>SCOWL (Spell Checker Oriented Word Lists)</i>: This word list is used
  in morphological generation to create all possible word forms of a given
  word.
<p></p>
  Copyright: <i>Copyright 2000-2011 by Kevin Atkinson. Permission to use, copy, modify, distribute and sell these word lists, the associated scripts, the output created from the scripts, and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appears in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Kevin Atkinson makes no representations about the suitability of this array for any purpose. It is provided "as is" without express or implied warranty.</i>
<p></p>
</li>
<li><i>Wall Street Journal</i>, part of the Penn Treebank 3: Morphologically
  annotated texts which are commonly used to train English POS tagger.
<p></p>
  Licensing: Available as LDC99T42 in LDC catalog under LDC User Agreement.
</li>
</ul>

<p>
The resulting models are distributed under the
<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</a> licence.
English models work in MorphoDiTa version 1.1 or later.
</p>
<p>
English models are versioned according to the release date, the version
format is <code>YYMMDD</code>, where <code>YY</code>, <code>MM</code> and <code>DD</code> are two-digit
representation of year, month and day, respectively. The latest version is
140407.
</p>

<a id="english-morphium-wsj_download" name="english-morphium-wsj_download"></a>
<h3>5.4.1. Download</h3>

<p>
The latest version 140407 of the English Morphium+WSJ models can be downloaded
from <a href="http://hdl.handle.net/11858/00-097C-0000-0023-68D9-0">LINDAT/CLARIN repository</a>.
</p>

<a id="english-morphium-wsj_acknowledgements" name="english-morphium-wsj_acknowledgements"></a>
<h3>5.4.2. Acknowledgements</h3>

<p>
This work has been using language resources developed and/or stored and/or
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <i>LM2010013</i>).
</p>
<p>
The morphological POS analyzer development was supported by grant of the Ministry
of Education, Youth and Sports of the Czech Republic No. <i>LC536</i> "Center for
Computational Linguistics". The morphological POS analyzer research was
performed by Johanka Spoustová (Spoustová 2008; the <code>Treex::Tool::EnglishMorpho::Analysis</code>
Perl module). The lemmatizer was implemented by Martin Popel (Popel 2009; the
<code>Treex::Tool::EnglishMorpho::Lemmatizer</code> Perl module). The lemmatizer is
based on <code>morpha</code>, which was released under LGPL licence as a part of
<a href="http://ilexir.co.uk/applications/rasp">RASP system</a>.
</p>
<p>
The tagger algorithm and feature set research was supported by the projects
<i>MSM0021620838</i> and <i>LC536</i> of Ministry of Education, Youth and Sports of the Czech Republic,
<i>GA405/09/0278</i> of the Grant Agency of the Czech Republic and <i>1ET101120503</i> of
Academy of Sciences of the Czech Republic. The research was performed by
Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab and Miroslav Spousta.
</p>

<a id="englich-morphium-wsj_publications" name="englich-morphium-wsj_publications"></a>
<h4>5.4.2.1. Publications</h4>

<ul>
<li>(Popel 2009) Martin Popel. <i><a href="http://ufal.mff.cuni.cz/~popel/papers/master_thesis.pdf">Ways to Improve the Quality of English-Czech Machine Translation.</a></i> Master Thesis at Institute of Formal and Applied Linguistics, Faculty of Mathematics and Physics, Charles University in Prague (2009).
<p></p>
</li>
<li>(Spoustová 2008) Drahomíra "johanka" Spoustová. <i><a href="http://ufal.mff.cuni.cz/morphium/">Morphium &ndash; morphological analyser for Penn treebank POS tagset.</a></i> Perl Software developed at Institute of Formal and Applied Linguistics, Faculty of Mathematics and Physics, Charles University in Prague (2008).
<p></p>
</li>
<li>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <i><a href="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</a></i> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
<p></p>
</li>
<li>(Straková et al. 2014) Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
</li>
</ul>

<a id="english-morphium-wsj_morphological_system" name="english-morphium-wsj_morphological_system"></a>
<h3>5.4.3. English Morphological System</h3>

<p style="margin-bottom:0">
The English morphology uses standard Penn Treebank POS tags. Nevertheless,
the lemma structure is unique:
</p>
<ul style="margin-top:0">
<li>The lemmatizer recognizes negative prefixes and removes it from the lemma.
  In terms of MorphoDiTa API, <i>raw lemma</i> is the lemma without negative prefix.
</li>
<li>The negative prefix is also stored to allow morphological generation of word
  form with the same negative prefix. In terms of MorphoDiTa API, <i>lemma id</i>
  is the raw lemma plus the negative prefix.
</li>
</ul>

<p>
The negative prefix is separated from the (always nonempty) lemma using a <code>^</code>
character (<code>able^un</code>). During morphological generation, the negative prefix is honored.
Furthermore, when the lemma ends with <code>^</code> (i.e., negative prefix is empty, as
in <code>able^</code>), forms with negative prefixes are generated. It is also possible
to generate all forms without any negative prefix by appending <code>+</code> after the lemma
(for example <code>able+</code>).
</p>

<a id="english-morphium-wsj_model" name="english-morphium-wsj_model"></a>
<h3>5.4.4. English Model</h3>

<p>
The English model contains the following files:
</p>

<dl>
<dt><code>english-morphium-&lt;version&gt;.dict</code></dt><dd>
  Morphological dictionary. The SCOWL word list has been automatically analyzed
  and lemmatized and uses as the dictionary. The guesser performing the analyzation
  and lemmatization is available.
<p></p>
</dd>
<dt><code>english-morphium-wsj-&lt;version&gt;.tagger</code></dt><dd>
  Tagger trained on the training portion of Wall Street Journal (Sections 0-18)
  and tuned on the development portion (Sections 19-21). Contains the
  <code>english-morphium-&lt;version&gt;.dict</code> morphological dictionary.
<p></p>
  The latest version <code>english-morphium-wsj-140407.tagger</code> reaches 97.27% tag
  accuracy on Wall Street Journal test portion (Section 22-24). Model speed: ~60k words/s,
  model size: 6MB.
</dd>
</dl>

<a id="english-morphium-wsj_no_negations_variant" name="english-morphium-wsj_no_negations_variant"></a>
<h3>5.4.5. No Negations Variant</h3>

<p>
Stripping of negative prefixes (or handling the lemmas with negative prefixes
stripped) may not be desirable. Therefore, a variant of the English model
denoted by <code>no_negation</code> is provided, which does not strip negative prefixes
from lemmas.
</p>

<dl>
<dt><code>english-morphium-&lt;version&gt;-no_negation.dict</code></dt><dd>
  Morphological dictionary which does not strip negative lemma prefixes. The
  SCOWL word list has been automatically analyzed and lemmatized and uses as
  the dictionary. The guesser performing the analyzation and lemmatization is
  available.
<p></p>
</dd>
<dt><code>english-morphium-wsj-&lt;version&gt;-no_negation.tagger</code></dt><dd>
  Tagger which does not strip negative lemma prefixes, trained on the training
  portion of Wall Street Journal (Sections 0-18) and tuned on the development
  portion (Sections 19-21). Contains the
  <code>english-morphium-&lt;version&gt;-no_negation.dict</code> morphological dictionary.
<p></p>
  The latest version <code>english-morphium-wsj-140407-no_negation.tagger</code> reaches 97.25%
  tag accuracy on Wall Street Journal test portion (Section 22-24). Model
  speed: ~60k words/s, model size: 6MB.
</dd>
</dl>

<a id="english-morphium-wsj_changes" name="english-morphium-wsj_changes"></a>
<h3>5.4.6. English Model Changes</h3>

<dl>
<dt><code>english-morphium-140407</code> and <code>english-morphium-wsj-140407</code> (require MorphoDiTa 1.1 or later)</dt><dd>
  Recognize also "non-" as a negative prefix. Formerly, only "non" was recognized.
<p></p>
</dd>
<dt><code>english-morphium-140304</code> and <code>english-morphium-wsj-140304</code> (require MorphoDiTa 1.0 or later)</dt><dd>
  Initial release.
</dd>
</dl>

<a id="run_tagger" name="run_tagger"></a>
<h2>5.5. Running the Tagger</h2>

<p style="margin-bottom:0">
Probably the most common usage of MorphoDita is running a tagger to tag your data using
</p>
<pre style="margin-top:0">
run_tagger tagger_model
</pre>

<p>
The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically.
</p>
<p>
Any number of files can be specified after the <code>tagger_model</code>. If an argument
<code>input_file:output_file</code> is used, the given <code>input_file</code> is processed and
the result is saved to <code>output_file</code>. If only <code>input_file</code> is used, the
result is saved to standard output. If no argument is given, input is read
from standard input and written to standard output.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>run_tagger</code> is
</p>
<pre style="margin-top:0">
run_tagger [options] tagger_file [file[:output_file]]...
Options: --input=untokenized|vertical
         --convert_tagset=pdt_to_conll2009|strip_lemma_comment|strip_lemma_id
         --derivation=none|root|path|tree
         --guesser=0|1 (should morphological guesser be used)
         --output=vertical|xml
</pre>

<a id="tagger_input_formats" name="tagger_input_formats"></a>
<h3>5.5.1. Input Formats</h3>

<p style="margin-bottom:0">
The input format is specified using the <code>--input</code> option. Currently supported
input formats are:
</p>
<ul style="margin-top:0">
<li><code>untokenized</code> (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
</li>
<li><code>vertical</code>: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.
</li>
</ul>

<a id="tagger_tagset_conversion" name="tagger_tagset_conversion"></a>
<h3>5.5.2. Tag Set Conversion</h3>

<p style="margin-bottom:0">
Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
</p>
<ul style="margin-top:0">
<li><code>pdt_to_conll2009</code>: convert Czech PDT tag set to CoNLL 2009 tag set,
</li>
<li><code>strip_lemma_comment</code>: strip lemma comment (see Lemma Structure in API Reference),
</li>
<li><code>strip_lemma_id</code>: strip lemma id (see Lemma Structure in API Reference).
</li>
</ul>

<a id="tagger_derivation" name="tagger_derivation"></a>
<h3>5.5.3. Morphological Derivation</h3>

<p style="margin-bottom:0">
If the morphological model includes a morphological derivator, some morphological
derivation operation may be performed on lemmas:
</p>
<ul style="margin-top:0">
<li><code>none</code> (default): no morphological derivation is performed
</li>
<li><code>root</code>: lemma is replaced by its root in the morphological derivation tree
</li>
<li><code>path</code>: lemma is replaced by a space separated path to its root in the
  morphological derivation tree (the original lemma is first, followed by its parent,
  with the root being the last one)
</li>
<li><code>tree</code>: whole morphological derivation tree is appended after the lemma,
  encoded in the following way: root node is the first, then the subtrees of
  the root children are encoded recursively (each after one space), followed by
  a final space (which denotes that the children are complete)
</li>
</ul>

<a id="tagger_morpho_guesser" name="tagger_morpho_guesser"></a>
<h3>5.5.4. Morphological Guesser</h3>

<p>
By default, every tagger model uses the morphological guesser settings employed
during the model training. However, the usage of morphological guesser can be
overridden by the <code>guesser</code> parameter.
</p>

<a id="tagger_output_formats" name="tagger_output_formats"></a>
<h3>5.5.5. Output Formats</h3>

<p style="margin-bottom:0">
The output format is specified using the <code>--output</code> option. Currently
supported output formats are:
</p>
<ul style="margin-top:0">
<li><code>xml</code> (default): Simple XML format without a root element, using
  <code>&lt;sentence&gt;</code> element to mark sentences and
  <code>&lt;token lemma="..." tag="..."&gt;...&lt;/token&gt;</code> element to encode token
  and its assigned lemma and tag.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code> (line breaks added):

<pre>
&lt;sentence&gt;&lt;token lemma='dítě' tag='NNFP1-----A----'&gt;Děti&lt;/token&gt;
&lt;token lemma='jet-1_^(pohybovat_se,_ne_však_chůzí)' tag='VB-P---3F-AA---'&gt;pojedou&lt;/token&gt;
&lt;token lemma='k-1' tag='RR--3----------'&gt;k&lt;/token&gt;
&lt;token lemma='babička' tag='NNFS3-----A----'&gt;babičce&lt;/token&gt;
&lt;token lemma='.' tag='Z:-------------'&gt;.&lt;/token&gt;&lt;/sentence&gt;
&lt;sentence&gt;&lt;token lemma='už-1' tag='Db-------------'&gt;Už&lt;/token&gt;
&lt;token lemma='se_^(zvr._zájmeno/částice)' tag='P7-X4----------'&gt;se&lt;/token&gt;
&lt;token lemma='těšit_:T' tag='VB-S---3P-AA---'&gt;těší&lt;/token&gt;
&lt;token lemma='.' tag='Z:-------------'&gt;.&lt;/token&gt;&lt;/sentence&gt;
</pre>

<p></p>
</li>
<li><code>vertical</code>: Every output line is a tag separated triple form-lemma-tag, with empty
  line denoting end of sentence.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code>:

<pre>
Děti	dítě	NNFP1-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------
babičce	babička	NNFS3-----A----
.	.	Z:-------------

Už	už-1	Db-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------
těší	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
</pre>

</li>
</ul>

<a id="running_morphology" name="running_morphology"></a>
<h2>5.6. Running the Morphology</h2>

<p>
There are multiple commands performing morphological tasks.
The <a href="#run_morpho_analyze"><code>run_morpho_analyze</code></a> executable performs morphological analysis and
the <a href="#run_morpho_generate"><code>run_morpho_generate</code></a> executable performs morphological generation.
The output of these commands is suitable for automatic processing.
</p>
<p>
The <a href="#run_morpho_cli"><code>run_morpho_cli</code></a> executable performs both morphological analysis and generation,
but is designed to be used interactively and produces more human-readable output.
</p>

<a id="run_morpho_analyze" name="run_morpho_analyze"></a>
<h3>5.6.1. Morphological Analysis</h3>

<p style="margin-bottom:0">
The morphological analysis can be performed by running
</p>
<pre style="margin-top:0">
run_morpho_analyze morphology_model use_guesser
</pre>

<p>
The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically. The input files are specified same as with the
<a href="#run_tagger"><code>run_tagger</code></a> command.
</p>
<p>
Some morphological models contain both a manually created dictionary and
a guesser. Therefore, a numeric <code>use_guesser</code> argument is required.
If non-zero, the guesser is used, otherwise not.
</p>
<p>
Because tagger models contain an embedded morphological model, a tagger model
can be used instead of morphological one if <code>--from_tagger</code> option is
specified.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>run_morpho_analyze</code> is
</p>
<pre style="margin-top:0">
run_morpho_analyze [options] morphology_model use_guesser [file[:output_file]]...
Options: --input=untokenized|vertical
         --convert_tagset=pdt_to_conll2009|strip_lemma_comment|strip_lemma_id
         --derivation=none|root|path|tree
         --output=vertical|xml
         --from_tagger
</pre>

<a id="run_morpho_analyze_input_formats" name="run_morpho_analyze_input_formats"></a>
<h4>5.6.1.1. Input Formats</h4>

<p style="margin-bottom:0">
The input format is specified using the <code>--input</code> option. Currently supported
input formats are:
</p>
<ul style="margin-top:0">
<li><code>untokenized</code> (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
</li>
<li><code>vertical</code>: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.
</li>
</ul>

<p>
Note that the input data is also segmented, even if it is not strictly
necessary. Therefore, the input is processed by whole paragraphs (ending
by an empty line).
</p>

<a id="run_morpho_analyze_tagset_conversion" name="run_morpho_analyze_tagset_conversion"></a>
<h4>5.6.1.2. Tag Set Conversion</h4>

<p style="margin-bottom:0">
Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
</p>
<ul style="margin-top:0">
<li><code>pdt_to_conll2009</code>: convert Czech PDT tag set to CoNLL 2009 tag set,
</li>
<li><code>strip_lemma_comment</code>: strip lemma comment (see Lemma Structure in API Reference),
</li>
<li><code>strip_lemma_id</code>: strip lemma id (see Lemma Structure in API Reference).
</li>
</ul>

<a id="run_morpho_analyze_derivation" name="run_morpho_analyze_derivation"></a>
<h4>5.6.1.3. Morphological Derivation</h4>

<p style="margin-bottom:0">
If the morphological model includes a morphological derivator, some morphological
derivation operation may be performed on lemmas:
</p>
<ul style="margin-top:0">
<li><code>none</code> (default): no morphological derivation is performed
</li>
<li><code>root</code>: lemma is replaced by its root in the morphological derivation tree
</li>
<li><code>path</code>: lemma is replaced by a space separated path to its root in the
  morphological derivation tree (the original lemma is first, followed by its parent,
  with the root being the last one)
</li>
<li><code>tree</code>: whole morphological derivation tree is appended after the lemma,
  encoded in the following way: root node is the first, then the subtrees of
  the root children are encoded recursively (each after one space), followed by
  a final space (which denotes that the children are complete)
</li>
</ul>

<a id="run_morpho_analyze_output_formats" name="run_morpho_analyze_output_formats"></a>
<h4>5.6.1.4. Output Formats</h4>

<p style="margin-bottom:0">
The output format is specified using the <code>--output</code> option. Currently
supported output formats are:
</p>
<ul style="margin-top:0">
<li><code>xml</code> (default): Simple XML format without a root element, using
  using <code>&lt;token&gt;&lt;analysis lemma="..." tag="..."/&gt;&lt;analysis...&gt;...&lt;/token&gt;</code>
  element to encode morphological analysis.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code> (line breaks added):

<pre>
&lt;sentence&gt;&lt;token&gt;&lt;analysis lemma="dítě" tag="NNFP1-----A----"/&gt;&lt;analysis lemma="dítě" tag="NNFP4-----A----"/&gt;&lt;analysis lemma="dítě" tag="NNFP5-----A----"/&gt;Děti&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="jet-1_^(pohybovat_se,_ne_však_chůzí)" tag="VB-P---3F-AA---"/&gt;pojedou&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="k-1" tag="RR--3----------"/&gt;&lt;analysis lemma="k-3_^(označení_pomocí_písmene)" tag="NNNXX-----A----"/&gt;&lt;analysis lemma="k-4`kůň_:B_^(jednotka_výkonu)" tag="NNMXX-----A---8"/&gt;&lt;analysis lemma="k-8_:B_^(ost._zkratka)" tag="XX------------8"/&gt;&lt;analysis lemma="komanditní_:B_^(jen_komanditní_společnost)" tag="AAXXX----1A---8"/&gt;&lt;analysis lemma="koncernový_:B" tag="AAXXX----1A---8"/&gt;&lt;analysis lemma="kuo-1_:B_,t_^(stará_jednotka_výkonu)" tag="NNNXX-----A---8"/&gt;k&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="babička" tag="NNFS3-----A----"/&gt;&lt;analysis lemma="babička" tag="NNFS6-----A----"/&gt;babičce&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="." tag="Z:-------------"/&gt;.&lt;/token&gt;&lt;/sentence&gt;
&lt;sentence&gt;&lt;token&gt;&lt;analysis lemma="už-1" tag="Db-------------"/&gt;&lt;analysis lemma="už-2" tag="TT-------------"/&gt;Už&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="se_^(zvr._zájmeno/částice)" tag="P7-X4----------"/&gt;&lt;analysis lemma="s-1" tag="RV--2----------"/&gt;&lt;analysis lemma="s-1" tag="RV--7----------"/&gt;se&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="těšit_:T" tag="VB-P---3P-AA---"/&gt;&lt;analysis lemma="těšit_:T" tag="VB-S---3P-AA---"/&gt;těší&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="." tag="Z:-------------"/&gt;.&lt;/token&gt;&lt;/sentence&gt;
</pre>

<p></p>
</li>
<li><code>vertical</code>: Every output line contains a word and a tab separated lemma-tag
  pairs assigned to the input word, with empty line denoting end of sentence.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code>:

<pre>
Děti	dítě	NNFP1-----A----	dítě	NNFP4-----A----	dítě	NNFP5-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------	k-3_^(označení_pomocí_písmene)	NNNXX-----A----	k-4`kůň_:B_^(jednotka_výkonu)	NNMXX-----A---8	k-8_:B_^(ost._zkratka)	XX------------8	komanditní_:B_^(jen_komanditní_společnost)	AAXXX----1A---8	koncernový_:B	AAXXX----1A---8	kuo-1_:B_,t_^(stará_jednotka_výkonu)	NNNXX-----A---8
babičce	babička	NNFS3-----A----	babička	NNFS6-----A----
.	.	Z:-------------

Už	už-1	Db-------------	už-2	TT-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------	s-1	RV--2----------	s-1	RV--7----------
těší	těšit_:T	VB-P---3P-AA---	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
</pre>

</li>
</ul>

<a id="run_morpho_generate" name="run_morpho_generate"></a>
<h3>5.6.2. Morphological Generation</h3>

<p style="margin-bottom:0">
The morphological generation can be performed by running
</p>
<pre style="margin-top:0">
run_morpho_generate morphology_model use_guesser
</pre>

<p>
The input is assumed to be in UTF-8 encoding. The input files are specified
same as with the <a href="#run_tagger"><code>run_tagger</code></a> command.
</p>
<p>
Input for morphological generation has to be in vertical format, each line
containing a lemma, which can be optionally followed by a tab and a
<a href="#run_morpho_generate_tag_wildcard">tag wildcard</a>. The output has the same number of lines as input,
line <i>l</i> contains tab separated form-lemma-tag triplets which can be generated
from the lemma on he input line <i>l</i>. If a tag wildcard was provided, only
triplets with matching tags are returned.
</p>
<p>
Some morphological models contain both a manually created dictionary and
a guesser. Therefore, a numeric <code>use_guesser</code> argument is required.
If non-zero, the guesser is used, otherwise not.
</p>
<p>
Because tagger models contain an embedded morphological model, a tagger model
can be used instead of morphological one if <code>--from_tagger</code> option is
specified.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>run_morpho_generate</code> is
</p>
<pre style="margin-top:0">
run_morpho_generate [options] morphology_model use_guesser [input_file[:output_file]]...
Options: --convert_tagset=pdt_to_conll2009|strip_lemma_comment|strip_lemma_id
         --from_tagger
</pre>

<p style="margin-bottom:0">
Example input data:
</p>
<pre style="margin-top:0">
dítě
jet	?[fN]??[-1]
k-1
babička	NNFS3-----A----
</pre>

<p style="margin-bottom:0">
Example output:
</p>
<pre style="margin-top:0">
dítě	dítě	NNNS1-----A----	dítě	dítě	NNNS4-----A----	dítě	dítě	NNNS5-----A----	dítěte	dítě	NNNS2-----A----	dítěti	dítě	NNNS3-----A----	dítěti	dítě	NNNS6-----A----	dítětem	dítě	NNNS7-----A----	děti	dítě	NNFP1-----A----	děti	dítě	NNFP4-----A----	děti	dítě	NNFP5-----A----	dětma	dítě	NNFP7-----A---6	dětmi	dítě	NNFP7-----A----	dětem	dítě	NNFP3-----A----	dětí	dítě	NNFP2-----A----	dětech	dítě	NNFP6-----A----	dětima	dítě_,h	NNFP7-----A---6
ject	jet	Vf--------A---6	jet	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------A----	jeti	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------A---2	nejet	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------N----	nejeti	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------N---2	jet	jet-2_,h_^(letadlo_s_tryskovým_pohonem)NNIS1-----A----	jety	jet-2_,h_^(letadlo_s_tryskovým_pohonem)	NNIP1-----A----
k	k-1	RR--3----------	ke	k-1	RV--3----------	ku	k-1	RV--3---------1
babičce babička NNFS3-----A----
</pre>

<a id="run_morpho_generate_tagset_conversion" name="run_morpho_generate_tagset_conversion"></a>
<h4>5.6.2.1. Tag Set Conversion</h4>

<p style="margin-bottom:0">
Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
</p>
<ul style="margin-top:0">
<li><code>pdt_to_conll2009</code>: convert Czech PDT tag set to CoNLL 2009 tag set,
</li>
<li><code>strip_lemma_comment</code>: strip lemma comment (see Lemma Structure in API Reference),
</li>
<li><code>strip_lemma_id</code>: strip lemma id (see Lemma Structure in API Reference).
</li>
</ul>

<p>
Note that the tag set conversion is applied only to the output, not to the
input lemmas and wildcards.
</p>

<a id="run_morpho_generate_tag_wildcard" name="run_morpho_generate_tag_wildcard"></a>
<h4>5.6.2.2. Tag Wildcards</h4>

<p>
When only forms with a specific tag should be generated for a given lemma, tag
wildcard can be specified. The tag wildcard is a simple wildcard allowing to filter
the results of morphological generation.
</p>
<p style="margin-bottom:0">
Most characters of a tag wildcard match corresponding characters of a tag, with the following exceptions:
</p>
 <ul style="margin-top:0">
 <li><code>?</code> matches any character of a tag.
 </li>
 <li><code>[chars]</code> matches any of the characters listed. The dash <code>-</code> has no special meaning and if <code>]</code>
   is the first character in <code>chars</code>, it is considered as one of the characters and does not end the group.
 </li>
 <li><code>[^chars]</code> matches any of the characters <i>not</i> listed.
 </li>
 </ul>

<a id="run_morpho_cli" name="run_morpho_cli"></a>
<h3>5.6.3. Interactive Morphological Analysis and Generation</h3>

<p style="margin-bottom:0">
Morphological analysis and generation which is interactive and more human readable
can be run using:
</p>
<pre style="margin-top:0">
run_morpho_cli morphology_model
</pre>

<p>
The input is read from standard input, command on each line. If there is no tab
on a line, analysis is performed on the given word. If there is a tab on
a line, generation is performed on the first word, using the second word as
a <a href="#run_morpho_generate_tag_wildcard">tag wildcard</a>.  If the second word is empty (i.e., the input
is for example ``on	``), all forms are generated.
</p>
<p>
Because tagger models contain an embedded morphological model, a tagger model
can be used instead of morphological one if <code>--from_tagger</code> option is
specified.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>run_morpho_cli</code> is
</p>
<pre style="margin-top:0">
run_morpho_cli [options] morphology_model
Options: --from_tagger
</pre>

<a id="run_tokenizer" name="run_tokenizer"></a>
<h2>5.7. Running the Tokenizer</h2>

<p>
Using the <code>run_tokenizer</code> executable it is possible to perform only
tokenization and segmentation.
</p>
<p>
The input is a UTF-8 encoded plain text and the input files are specified same
as with the <a href="#run_tagger"><code>run_tagger</code></a> command.
</p>
<p style="margin-bottom:0">
The tokenizer can be specified either by using a morphology model
(<code>--morphology</code> option), tagger model (<code>--tagger</code> option) or by using
a tokenizer identifier (<code>--tokenizer</code> option). Currently supported
tokenizer identifiers are:
</p>
<ul style="margin-top:0">
<li><code>czech</code>
</li>
<li><code>english</code>
</li>
<li><code>generic</code>
</li>
</ul>

<p style="margin-bottom:0">
The full command syntax of <code>run_tokenizer</code> is
</p>
<pre style="margin-top:0">
run_tokenizer [options] [file[:output_file]]...
Options: --tokenizer=czech|english|generic
         --morphology=morphology_model_file
         --tagger=tagger_model_file
         --output=vertical|xml
</pre>

<a id="run_tokenizer_output_formats" name="run_tokenizer_output_formats"></a>
<h3>5.7.1. Output Formats</h3>

<p style="margin-bottom:0">
The output format is specified using the <code>--output</code> option. Currently
supported output formats are:
</p>
<ul style="margin-top:0">
<li><code>xml</code> (default): Simple XML format without a root element, using
  <code>&lt;sentence&gt;</code> element to mark sentences and <code>&lt;token&gt;</code> element to mark
  tokens.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code> (line breaks added):

<pre>
&lt;sentence&gt;&lt;token&gt;Děti&lt;/token&gt; &lt;token&gt;pojedou&lt;/token&gt; &lt;token&gt;k&lt;/token&gt;
&lt;token&gt;babičce&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt; &lt;sentence&gt;&lt;token&gt;Už&lt;/token&gt;
&lt;token&gt;se&lt;/token&gt; &lt;token&gt;těší&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt;
</pre>

<p></p>
</li>
<li><code>vertical</code>: Each token is on a separate line, every sentence is ended by
  a blank line.
<p></p>
  Example output for input <code>Děti pojedou k babičce. Už se těší.</code>:

<pre>
Děti
pojedou
k
babičce
.

Už
se
těší
.

</pre>

</li>
</ul>

<a id="rest_server" name="rest_server"></a>
<h2>5.8. Running REST Server</h2>

<p>
MorphoDiTa also provides REST server binary <code>morphodita_server</code>.
The binary uses <a href="http://github.com/ufal/microrestd">MicroRestD</a> as a REST
server implementation and provides
<a href="http://lindat.mff.cuni.cz/services/morphodita/api-reference.php">MorphoDiTa REST API</a>.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>morphodita_server</code> is
</p>
<pre style="margin-top:0">
morphodita_server [options] port (model_name model_file acknowledgements)*
Options: --connection_timeout=maximum connection timeout [s] (default 60)
         --daemon (daemonize after start, supported on Linux only)
         --log_file=file path (no logging if empty, default morphodita_server.log)
         --log_request_max_size=max req log size [kB] (0 unlimited, default 64)
         --max_connections=maximum network connections (default 256)
         --max_request_size=maximum request size [kB] (default 1024)
         --threads=threads to use (default 0 means unlimitted)
</pre>

<p>
The <code>morphodita_server</code> can run either in foreground or in background (when
<code>--daemon</code> is used). The specified model files are loaded during start and
kept in memory all the time. This behaviour might change in future to load the
models on demand.
</p>

<a id="custom_models" name="custom_models"></a>
<h2>5.9. Custom Morphological and Tagging Models</h2>

<p>
It is possible to create custom morphological and tagging models.
</p>

<a id="custom_morphological_models" name="custom_morphological_models"></a>
<h3>5.9.1. Custom Morphological Models</h3>

<p>
Custom morphological models can be created using <code>encode_dictionary</code> binary.
</p>
<p>
The <code>encode_dictionary</code> reads from standard input and prints MorphoDiTa
morphological model on standard output.  The input of <code>encode_dictionary</code> is
a textual representation of morphological dictionary. It should be UTF-8
encoded and every line should be a tab separated triplet
<code>lemma \t tag \t form</code>. All forms of one lemma must appear in a continuous region and no line
should appear more than once (<code>sort -u</code> can be used to achieve this).
</p>
<p style="margin-bottom:0">
Run <code>encode_dictionary</code> with the following options:
</p>
<pre style="margin-top:0">
encode_dictionary generic max_suffix_len unknown_tag number_tag punctuation_tag symbol_tag [statistical_guesser]
</pre>

<ul>
<li><code>generic</code>: This parameter defines tokenizer and other language specific
  behaviour. Other values than <code>generic</code> take different options and are not
  documented.
<p></p>
</li>
<li><code>max_suffix_len</code>: Maximum length of suffixes in automatically inferred
  inflexion classes.  If unsure, use 8 (we use 8 for Czech and 4 for English).
  Smaller values produce larger and slightly faster models.
<p></p>
</li>
<li><code>unknown_tag</code>: Assigned to a form during analysis if no matching tag can be
  found.
<p></p>
</li>
<li><code>number_tag</code>: Assigned to a form during analysis if the form was not found
  in the dictionary and it looks like a number. Can be the same as
  <code>unknown_tag</code>.
<p></p>
</li>
<li><code>punctuation_tag</code>: Assigned to a form during analysis if the form was not found
  in the dictionary and it consists of Unicode characters in the Punctuation
  category. Can be the same as <code>unknown_tag</code>.
<p></p>
</li>
<li><code>symbol_tag</code>: Assigned to a form during analysis if the form was not found
  in the dictionary and it consists of Unicode characters in the Symbol
  category. Can be the same as <code>unknown_tag</code>.
<p></p>
</li>
<li><code>statistical_guesser</code>: Optional file containing statistical guesser generated
  using the <code>train_guesser</code> binary (see below).
</li>
</ul>

<p style="margin-bottom:0">
Example input data:
</p>
<pre style="margin-top:0">
dog	NN	dog
dog	NNS	dogs
go	VB	go
go	VBP	go
go	VBZ	goes
go	VBG	going
go	VBD	went
</pre>

<p style="margin-bottom:0">
Example command line:
</p>
<pre style="margin-top:0">
encode_dictionary generic 8 UNK NUM PUNC SYM &lt;input_data &gt;output_model
</pre>

<a id="training_statistical_guesser" name="training_statistical_guesser"></a>
<h4>5.9.1.1. Training Statistical Guesser</h4>

<p>
Optionally, statistical guesser might be trained on disambiguated
data using the <code>train_guesser</code> binary.
</p>
<p>
The input data is in the same format as the training data for the tagger,
i.e., every word on a line (each line containing tab separated triplet
<code>form \t lemma \t tag</code> in UTF-8 encoding), with end of sentence denoted
by an empty line. Note that the input data must not contain spaces.
</p>
<p style="margin-bottom:0">
The full command syntax of <code>train_guesser</code> is:
</p>
<pre style="margin-top:0">
train_guesser [options] suffix_len rules_per_suffix &lt;input_data &gt;output_guesser
Options: --max_prefixes=maximum number of prefixes to create
         --min_prefix_count=minimum count to create a prefix
</pre>

<ul>
<li><code>suffix_len</code>: Generate guesser rules using suffixes of length at most
  <code>suffix_len</code>(for Czech we use 3).
</li>
<li><code>rules_per_suffix</code>: Maximum number of guesser rules generated per suffix
  (for Czech we use 8 for a rich tag set (more than a thousand tags) and 6 for
  a coarse tag set (67 tags)).
</li>
<li><code>max_prefixes</code>: The guesser rules might also be specific for several prefixes.
  There might be at most <code>max_prefixes</code> such prefixes. Note that the more
  prefixes are allowed, the large the guesser is (for Czech we set this to 0,
  but for some other languages we also use 4).
</li>
<li><code>min_prefix_count</code>: In order for a prefix to be considered, it has to occur
  at most the specified number of times in the data.
</li>
</ul>

<a id="using_external_morphology" name="using_external_morphology"></a>
<h4>5.9.1.2. Using External Morphology</h4>

<p>
Sometimes it is useful to train MorphoDiTa tagger using external morphological
analysis, without having a MorphoDiTa morphological dictionary.
</p>
<p style="margin-bottom:0">
That is possible using a so called <i>external morphology model</i>. External
morphology model can be created easily using
</p>
<pre style="margin-top:0">
encode_dictionary external unknown_tag &gt;output_model
</pre>

<p>
No standard input is read in this case. The <code>unknown_tag</code> parameter is used when
no tag is assigned to a word form during analysis. The resulting model is
printed on standard output.
</p>
<p>
The external morphology model does not contain any morphological dictionary.
Instead, it expects the user to perform morphological analysis and generation on
their own. Therefore, the input form to analysis is expected to be followed by
space separated lemma-tag pairs, which are returned by the analysis.
Similarly, the input lemma to generation is expected to be followed by space
separated form-tag pairs, which are again returned by the generation (possibly
filtered by a tag wildcard). (To extract the length of the form or lemma itself
even when followed by external analyses, API calls <code>raw_form_len</code> or
<code>raw_lemma_len</code> and <code>lemma_id_len</code> can be used.)
</p>
<p>
Note that the tokenizer returned by the external morphology model is the same
as the tokenizer of the generic model, and splits input on spaces. Therefore,
it can be used to tokenize input, the tokens then passed to the external
morphology, and the results can be after proper formatting used as input to
MorphoDiTa in vertical input format.
</p>
<p style="margin-bottom:0">
Example input form for analysis using external morphology model:
</p>
<pre style="margin-top:0">
wishes wish NNS wish VBZ
</pre>

<p style="margin-bottom:0">
Example input lemma for generation using external morphology model:
</p>
<pre style="margin-top:0">
go go VB go VBP goes VBZ going VBG went VBG
</pre>

<a id="custom_tagging_models" name="custom_tagging_models"></a>
<h3>5.9.2. Custom Tagging Models</h3>

<p style="margin-bottom:0">
Custom tagging models can be trained using <code>train_tagger</code> binary, which has
the following options:
</p>
<pre style="margin-top:0">
train_tagger generic_234 morphology use_guesser features iterations prune_features [heldout_data [early_stopping]] &lt;input_data &gt;tagger_model
</pre>

<ul>
<li><code>generic_234</code>: This parameter defines the tagger (elementary features and
  algorithm) and the order of Viterbi decoding. Use either <code>generic2</code>,
  <code>generic3</code> or <code>generic4</code>. If unsure, use <code>generic3</code> (best released
  Czech and English models use <code>generic3</code>). The <code>generic2</code> produces faster,
  but less accurate models, <code>generic4</code> produces larger and only marginally
  better models.
<p></p>
</li>
<li><code>morphology</code>: File with the morphological dictionary to use.
<p></p>
</li>
<li><code>use_guesser</code>: Use <code>0</code>/<code>1</code> to specify whether morphological guesser
  should be used. Unless you have a good reason not to, use <code>1</code>.
<p></p>
</li>
<li><code>features</code>: File with feature sequences for the tagger. The file format and available
  elementary features are <a href="#tagger_feature_file_format">described in following section</a>.
<p></p>
</li>
<li><code>iterations</code>: Number of training iterations. For English, values 5-10 are used,
  for Czech, values 10-15 are used. Can be affected by <code>early_stopping</code>.
<p></p>
</li>
<li><code>prune_features</code>: Use <code>0</code>/<code>1</code> to disable/enable pruning of feature
  sequences not found in training data. Use <code>1</code> for smaller and marginally
  less accurate models, and <code>0</code> for larger and marginally better models.
  If unsure, use <code>1</code> (best released Czech and English models use <code>1</code>).
<p></p>
</li>
<li><code>heldout_data</code>: Optional file with heldout data in the same format as input
  data.  If supplied, accuracy is measured on the heldout data after every
  training iteration.
<p></p>
</li>
<li><code>early_stopping</code>: Optionally use <code>0</code>/<code>1</code> to disable/enable early
  stopping. If early stopping is enabled, the resulting model is not the one
  after the last training iteration, but the one with best heldout data
  accuracy.
</li>
</ul>

<p style="margin-bottom:0">
Example command line (use morphology from <code>morpho.dict</code>, features from <code>features.ft</code> and no heldout data):
</p>
<pre style="margin-top:0">
train_tagger generic3 morpho.dict 1 features.ft 10 1 &lt;input.data &gt;tagger.model
</pre>

<p style="margin-bottom:0">
Example command line (use morphology from <code>morpho.dict</code>, features from <code>features.ft</code> and use heldout data with early stopping):
</p>
<pre style="margin-top:0">
train_tagger generic3 morpho.dict 1 features.ft 15 1 heldout.data 1 &lt;input.data &gt;tagger.model
</pre>

<p>
See next sections for examples of input data and feature files.
</p>

<a id="tagger_input_format" name="tagger_input_format"></a>
<h4>5.9.2.1. Input Data Format</h4>

<p>
The input data (and the heldout data) represent a sequence of sentences.
Different sentences do not interact in any way. Words of one sentence are
stored on consecutive lines, each line containing tab separated triplet
<code>form \t lemma \t tag</code> in UTF-8 encoding. End of sentence is denoted
by an empty line.
</p>
<p style="margin-bottom:0">
Example:
</p>
<pre style="margin-top:0">
Děti	dítě	NNFP1-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------
babičce	babička	NNFS3-----A----
.	.	Z:-------------

Už	už-1	Db-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------
těší	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
</pre>

<a id="tagger_feature_file_format" name="tagger_feature_file_format"></a>
<h4>5.9.2.2. Feature File Format</h4>

<p style="margin-bottom:0">
The features used in the tagger have major influence on tagging performance.
The feature file contains several <i>feature sequences</i>, each sequence
consisting of several <i>elementary features</i>. The elementary features are
computed by MorphoDiTa and different tagger models can have a different set of
elementary features. Here we describe elementary features of <code>generic</code>
tagger:
</p>
<ul style="margin-top:0">
<li><code>Form</code>: word form
</li>
<li><code>Prefix1</code> .. <code>Prefix9</code>: word form prefix of length 1..9 (measured in Unicode characters)
</li>
<li><code>Suffix1</code> .. <code>Suffix9</code>: word form suffix of length 1..9 (measured in Unicode characters)
</li>
<li><code>Num</code>: whether the word form contains at least one numbers (Unicode category Number)
</li>
<li><code>Cap</code>: whether the word form contains at least one uppercase or titlecase letter
</li>
<li><code>Dash</code>: whether the word form contains at least one dash (Unicode category 'Punctuation, Dash')
</li>
<li><code>Tag</code>: word form PoS tag
</li>
<li><code>Tag1</code> .. <code>Tag5</code>: letter 1..5 of word form PoS tag
</li>
<li><code>Lemma</code>: word form lemma
</li>
<li><code>FollowingVerbTag</code>: PoS tag of a nearest following verb, i.e., a nearest
  following word form with at least one of the PoS tags starting with <code>V</code>
</li>
<li><code>FollowingVerbLemma</code>: lemma of a nearest following verb, i.e., a nearest
  following word form with at least one of the PoS tags starting with <code>V</code>
</li>
<li><code>PreviousVerbTag</code>: PoS tag of a nearest previous verb, i.e., a nearest
  previous word whose PoS tag (assigned by the tagger) starts with <code>V</code>
</li>
<li><code>PreviousVerbTag</code>: lemma of a nearest previous verb, i.e., a nearest
  previous word whose PoS tag (assigned by the tagger) starts with <code>V</code>
</li>
</ul>

<p>
The feature file defines <i>feature sequences</i> which can be applied to a word
form. A feature sequence consists of elementary features assigned to the given
form or its neighbours.
</p>
<p>
Every line in the feature file defines one feature sequence. A feature sequence
consists of comma joined space separated pairs of elementary feature and an
offset to which does the elementary feature apply (i.e., <code>Form 0</code> or
<code>Tag 0,Lemma -1</code>). The file format is strict and does not allow any
additional spaces or commas.
</p>
<p>
Note that offset of some of the elementary features is affected by the order or
Viterbi decoding used. Notably, if Viterbi decoding of order <i>N</i> is utilized,
<code>Tag</code> and <code>Lemma</code> can be used inside the decoded window, i.e., only with
offsets <i>-N+1</i> .. <i>0</i>.
</p>
<p>
For inspiration, we present feature files used for releases Czech
and English MorphoDiTa models. Both these feature files are slight
modifications of feature files described in the paper
Spoustová et al. 2009: Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <i><a href="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</a></i> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
</p>
<p style="margin-bottom:0">
Feature file for English:
</p>
<pre style="margin-top:0">
Tag 0,Form 0
Tag 0,Prefix1 0
Tag 0,Prefix2 0
Tag 0,Prefix3 0
Tag 0,Prefix4 0
Tag 0,Prefix5 0
Tag 0,Prefix6 0
Tag 0,Prefix7 0
Tag 0,Prefix8 0
Tag 0,Prefix9 0
Tag 0,Suffix1 0
Tag 0,Suffix2 0
Tag 0,Suffix3 0
Tag 0,Suffix4 0
Tag 0,Suffix5 0
Tag 0,Suffix6 0
Tag 0,Suffix7 0
Tag 0,Suffix8 0
Tag 0,Suffix9 0
Tag 0,Num 0
Tag 0,Cap 0
Tag 0,Dash 0
Tag 0,Tag -1
Tag 0,Tag -1,Tag -2
Tag 0,Form -1
Tag 0,Form -2
Tag 0,Form -1,Form -2
Tag 0,Form 1
Tag 0,Form 1,Form 2
Tag 0,Tag1 -1
Tag 0,Lemma -1
Lemma 0,Tag -1
</pre>

<p style="margin-bottom:0">
Feature file for Czech (note that some feature sequences predict only part of
PoS tags trying to overcome data sparseness; <code>Tag2</code> is extended PoS, <code>Tag3</code>
is gender, <code>Tag5</code> is case):
</p>
<pre style="margin-top:0">
Tag 0
Tag 0,Tag -1
Tag 0,Tag -1,Tag -2
Tag 0,Tag -2
Tag 0,Form 0
Tag 0,Form 0,Form -1
Tag 0,Form -1
Tag 0,Form -2
Tag 0,PreviousVerbTag 0
Tag 0,PreviousVerbLemma 0
Tag 0,FollowingVerbTag 0
Tag 0,FollowingVerbLemma 0
Tag 0,Lemma -1
Lemma 0,Tag -1
Tag 0,Form 1
Tag2 0,Tag5 0
Tag2 0,Tag5 0,Tag2 -1,Tag5 -1
Tag2 0,Tag5 0,Tag2 -1,Tag5 -1,Tag2 -2,Tag5 -2
Tag5 0
Tag5 0,Tag -1
Tag5 0,Tag -1,Tag -2
Tag5 0,Tag -2
Tag5 0,Form 0
Tag5 0,Form 0,Form -1
Tag5 0,Form -1
Tag5 0,Form -2
Tag5 0,PreviousVerbTag 0
Tag5 0,PreviousVerbLemma 0
Tag5 0,FollowingVerbTag 0
Tag5 0,FollowingVerbLemma 0
Tag5 0,Lemma -1
Tag5 0,Form 1
Tag3 0
Tag3 0,Tag -1
Tag3 0,Tag -1,Tag -2
Tag3 0,Tag -2
Tag3 0,Form 0
Tag3 0,Form 0,Form -1
Tag3 0,Form -1
Tag3 0,Form -2
Tag3 0,PreviousVerbTag 0
Tag3 0,PreviousVerbLemma 0
Tag3 0,FollowingVerbTag 0
Tag3 0,FollowingVerbLemma 0
Tag3 0,Lemma -1
Tag3 0,Form 1
Tag 0,Prefix1 0
Tag 0,Prefix2 0
Tag 0,Prefix3 0
Tag 0,Prefix4 0
Tag 0,Suffix1 0
Tag 0,Suffix2 0
Tag 0,Suffix3 0
Tag 0,Suffix4 0
Tag 0,Num 0
Tag 0,Cap 0
Tag 0,Dash 0
Tag5 0,Suffix1 0
Tag5 0,Suffix2 0
Tag5 0,Suffix3 0
Tag5 0,Suffix4 0
</pre>

<p style="margin-bottom:0">
Feature file for Czech, Part of Speech only variant:
</p>
<pre style="margin-top:0">
Tag 0
Tag 0,Tag -1
Tag 0,Tag -1,Tag -2
Tag 0,Tag -2
Tag 0,Form 0
Tag 0,Form 0,Form -1
Tag 0,Form -1
Tag 0,Form -2
Tag 0,PreviousVerbTag 0
Tag 0,PreviousVerbLemma 0
Tag 0,FollowingVerbTag 0
Tag 0,FollowingVerbLemma 0
Tag 0,Lemma -1
Lemma 0,Tag -1
Tag 0,Form 1
Tag 0,Prefix1 0
Tag 0,Prefix2 0
Tag 0,Prefix3 0
Tag 0,Prefix4 0
Tag 0,Suffix1 0
Tag 0,Suffix2 0
Tag 0,Suffix3 0
Tag 0,Suffix4 0
Tag 0,Num 0
Tag 0,Cap 0
Tag 0,Dash 0
</pre>

<a id="tagger_accuracy" name="tagger_accuracy"></a>
<h4>5.9.2.3. Measuring Tagger Accuracy</h4>

<p style="margin-bottom:0">
Measuring custom tagger accuracy can be performed by running:
</p>
<pre style="margin-top:0">
tagger_accuracy tagger_model &lt;test_data
</pre>

<p>
This binary reads input in the <a href="#tagger_input_format">same format as <code>train_tagger</code></a>,
i.e., tab separated form-lemma-tag triplets, and evaluates the accuracy
of the tagger model on the given testing data.
</p>

<a id="api_tutorial" name="api_tutorial"></a>
<h1>6. MorphoDiTa API Tutorial</h1>

<p>
The MorphoDiTa API is defined in header <code>morphodita.h</code> and resides in
<code>ufal::morphodita</code> namespace. The easiest way to use MorphoDita is therefore:
</p>

<pre>
#include morphodita.h

using namespace ufal::morphodita;
</pre>

<a id="tutorial_tagger_api" name="tutorial_tagger_api"></a>
<h2>6.1. Tagger API</h2>

<p>
The main access to MorphoDiTa tagger is through class <code>tagger</code>.  An example
of this class usage can be found in program file <code>run_tagger.cpp</code>. A typical
tagger usage may look like this:
</p>

<pre>
#include tagger/tagger.h;

using namespace ufal::morphodita;

//...

// load model to memory and construct tagger
tagger* my_tagger = tagger::load("path_to_model");

if (!t) ...

// create sample input
vector&lt;string&gt; words;
words.push_back("malý");
words.push_back("pes");

vector&lt;string_piece&gt; forms;
for (auto&amp; word : words)
  forms.emplace_back(word)

// intialize output and tag
vector&lt;tagged_lemma&gt; tags;
my_tagger-&gt;tag(forms, tags);

// access the output
for (auto&amp; tag : tags)
  printf("%s\t%s\n", tag.lemma.c_str(), tag.tag.c_str());

delete my_tagger;
</pre>

<p>
The tagger is constructed by an overloaded factory method with one argument.
The constructor either accepts an input stream (<code>istream&amp;</code>)
with the model or a C string (<code>const char*</code>) with a file name of the model.
The constructor loads the linguistic model to memory and returns the tagger
pointer ready for tagging, returning <code>NULL</code> if unsuccessful. If an input
stream is used, it is positioned right after the end of the
model.
</p>
<p>
The main tagging method is <code>tagger::tag</code>:
</p>

<pre>
void tag(const std::vector&lt;string_piece&gt;&amp; forms, std::vector&lt;tagged_lemma&gt;&amp; tags) const;
</pre>

<p>
The input is a <code>std::vector</code> of <code>string_piece</code> which is a structure
referencing a string using <code>const char* str</code> and <code>size_t len</code>.
</p>
<p>
The <code>tagger::tag</code> method returns the tagged output in it's second argument,
<code>std::vector&lt;tagged_lemma&gt;</code>. The calling procedure must provide a result vector
and the tagger assigns the output to this vector. Obviously, the indexes in the
output vector correspond to indexes in input vector.  <code>tagged_lemma</code> has two
public members: <code>std::string lemma</code> and <code>std:string tag</code>, corresponding to
predicted lemma and tag, respectively.
</p>

<a id="tutorial_morpho_api" name="tutorial_morpho_api"></a>
<h2>6.2. Morphological Dictionary API</h2>

<p>
The main access to MorphoDiTa morphological dictionary is through class
<code>morpho</code>. An example of this interface usage can be found in a program file
<code>run_morpho.cpp</code>.
</p>

<a id="tutorial_morpho_construction" name="tutorial_morpho_construction"></a>
<h3>6.2.1. Dictionary Construction</h3>

<p>
Similarly to the tagger, MorphoDiTa morphological dictionary is constructed by an
overloaded factory method which accepts either an input stream (<code>istream&amp;</code>)
or a C string <code>const char*</code> with the file name of the dictionary.
The factory method returns a pointer to morphological dictionary or <code>NULL</code> if
unsuccessful.
</p>

<pre>
#include morpho/morpho.h

using namespace ufal::morphodita;

//...

// load dictionary to memory
morpho* my_morpho = morpho::load("path_to_dictionary");

//...

delete(my_morpho);
</pre>

<p>
Another way of obtaining a pointer to morphology dictionary is through an instance
of <code>tagger</code> class &ndash; every tagger has a morphology dictionary, which is available
through the method
</p>

<pre>
virtual const morpho* get_morpho() const = 0;
</pre>

<p>
Please note that you should not delete this pointer as it is owned by the
<code>tagger</code> class instance.
</p>

<a id="tutorial_morpho_analysis" name="tutorial_morpho_analysis"></a>
<h3>6.2.2. Morphological Analysis</h3>

<p>
MorphoDiTa morphological dictionary offers two functionalities: It either
<i>analyzes</i> the given word, that means it outputs all possible lemma-tag pairs
candidates for the given form; or for a given lemma-tag pair, it <i>generates</i>
a form or a whole list of possible forms.
</p>
<p>
In the first case, one performs morphological analysis for a given word by
calling a method <code>morpho::analyze</code>:
</p>

<pre>
int analyze(string_piece form, guesser_mode guesser, std::vector&lt;tagged_lemma&gt;&amp; lemmas) const;
</pre>

<p>
An example (assuming that morphological dictionary is already constructed, see
previous example):
</p>

<pre>
vector&lt;tagged_lemma&gt; lemmas;    // output

my_morpho-&gt;analyze("pes", morpho::GUESSER, vector&lt;tagged_lemma&gt;&amp; lemmas);

for (auto&amp; lemma: lemmas)
  printf ("%s %s\n, lemma.lemma.c_str(), lemma.tag.c_str())
</pre>

<p>
The input is a form to analyze, then a Guesser mode (whether to use some kind
of guesser or strictly dictionary only, see question Guesser Mode in
<a href="#faq">Questions and Answers</a>) and output <code>std::vector&lt;tagged_lemma&gt;</code>.  The
caller must provide an output vector <code>std::vector&lt;tagged_lemma&gt;</code> and the
method <code>morpho::analyze</code> assigns the output to this vector.
</p>

<a id="tutorial_morpho_generation" name="tutorial_morpho_generation"></a>
<h3>6.2.3. Generation</h3>

<p>
MorphoDiTa performs morphological generation from a given lemma:
</p>

<pre>
int generate(string_piece lemma, const char* tag_wildcard, guesser_mode guesser,
             std::vector&lt;tagged_lemma_forms&gt;&amp; forms) const;
</pre>

<a id="tutorial_tag_wildcard" name="tutorial_tag_wildcard"></a>
<h4>6.2.3.1. Tag Wildcard</h4>

<p>
Optionally, a tag wildcard can be specified (or be <code>NULL</code>) and if so, results
are filtered using this wildcard. This method can be therefore used in more
ways: One may wish to generate all possible forms and their tags from a given
lemma. Then the <code>tag_wildcard</code> is set to <code>NULL</code> and the method generates
all possible combinations. One may also need a generate a specific form and tag
from a given lemma, then <code>tag_wildcard</code> is set to this tag value.
</p>
<p>
Or even more, for example, in the Czech positional morphology tagging system
(<a href="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</a>),
one may even wish to generate something like "all forms in fourth case",
then <code>tag_wildcard</code> should be set to <code>????4</code>.
Please see Section "Czech Morphology" in User's Manual for more details about the Czech positional tagging system.
The previous example applies to morphological annotation of
<a href="http://ufal.mff.cuni.cz/pdt3.0">PDT</a>, however, the tag wildcards can be used in any
morphological tagging system.
</p>
<p style="margin-bottom:0">
Most characters of a tag wildcard match corresponding characters of a tag, with the following exceptions:
</p>
 <ul style="margin-top:0">
 <li><code>?</code> matches any character of a tag.
 </li>
 <li><code>[chars]</code> matches any of the characters listed. The dash <code>-</code> has no special meaning and if <code>]</code>
   is the first character in <code>chars</code>, it is considered as one of the characters and does not end the group.
 </li>
 <li><code>[^chars]</code> matches any of the characters <i>not</i> listed.
 </li>
 </ul>

<a id="tutorial_unknown_lemmas" name="tutorial_unknown_lemmas"></a>
<h4>6.2.3.2. Unknown Lemmas</h4>

<p>
When the lemma is unknown, MorphoDiTa's generation behavior is defined by Guesser mode (see also
question Guesser Mode in Questions and Answers). If at least one lemma is found
in the dictionary, <code>NO_GUESSER</code> is returned. If <code>guesser == GUESSER</code> and the lemma
is found by the guesser, <code>GUESSER</code> is returned. Otherwise, forms are cleared and
<code>-1</code> is returned.
</p>

<a id="faq" name="faq"></a>
<h2>6.3. Questions and Answers</h2>

<dl>
<dt><b>What is a Guesser Mode?</b></dt><dd>
  Morphological analysis may try to guess the lemma and tag of an uknown word.
  This option is turned on by <code>morpho::GUESSER</code> and off by
  <code>morpho::NO_GUESSER</code>.
<p></p>
</dd>
<dt><b>Why `string_piece`` and not <code>const char*</code> or <code>std::string</code>?</b></dt><dd>
  We aim to make MorphoDiTa interface as effective as possible. Because the
  input strings may be substrings of larger text or come from different than
  C++ memory regions, we want to avoid the cost of <code>\\0</code> padding or
  <code>string</code> conversion. Nevertheless, both <code>const char*</code> and
  <code>std::string</code> can be used instead of a <code>string_piece</code> because of existing
  implicit conversion rules.
</dd>
</dl>

<a id="api_reference" name="api_reference"></a>
<h1>7. MorphoDiTa API Reference</h1>

<p>
The MorphoDiTa API is defined in header <code>morphodita.h</code> and resides in
<code>ufal::morphodita</code> namespace.
</p>
<p>
The strings used in the MorphoDiTa API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).
</p>

<a id="versioning" name="versioning"></a>
<h2>7.1. MorphoDiTa Versioning</h2>

<p>
MorphoDiTa is versioned using <a href="http://semver.org/">Semantic Versioning</a>.
Therefore, a version consists of three numbers <i>major.minor.patch</i>, optionally
followed by a hyphen and pre-release version info, with the following semantics:
</p>

<ul>
<li>Stable versions have no pre-release version info, development have non-empty
  pre-release version info.
</li>
<li>Two versions with the same <i>major.minor</i> have the same API with the same
  behaviour, apart from bugs. Therefore, if only <i>patch</i> is increased, the
  new version is only a bug-fix release.
</li>
<li>If two versions <i>v</i> and <i>u</i> have the same <i>major</i>, but <i>minor(v)</i> is
  greater than <i>minor(u)</i>, version <i>v</i> contains only additions to the API.
  In other words, the API of <i>u</i> is all present in <i>v</i> with the same
  behaviour (once again apart from bugs). It is therefore safe to upgrade to
  a newer MorphoDiTa version with the same <i>major</i>.
</li>
<li>If two versions differ in <i>major</i>, their API may differ in any way.
</li>
</ul>

<p>
Models created by MorphoDiTa have the same behaviour in all MorphoDiTa
versions with same <i>major</i>, apart from obvious bugfixes. On the other hand,
models created from the same data by different <i>major.minor</i> MorphoDiTa
versions may have different behaviour.
</p>

<a id="lemma_structure" name="lemma_structure"></a>
<h2>7.2. Lemma Structure</h2>

<p>
The lemmas used by MorphoDiTa consist of three parts:
</p>

<ol>
<li><i>raw lemma</i>: text form of the lemma. May not uniquely distinguish
  lemma meanings, lemma use cases etc.
</li>
<li><i>lemma id</i>: together with raw lemma provide a unique identifier of the lemma,
  possibly including lemma meanings or use cases.
</li>
<li><i>lemma comments</i>: additional comments for the given lemma.
</li>
</ol>

<p>
These parts are stored in one string and the boundaries between them can be
determined by
<a href="#morpho_raw_lemma_len"><code>morpho::raw_lemma_len</code></a> and
<a href="#morpho_lemma_id_len"><code>morpho::lemma_id_len</code></a> methods.
Analyzer and tagger always return lemma in this structured form. When
performing morphological generation, either <i>raw lemma</i> or both <i>raw lemma</i> and
<i>lemma id</i> can be specified, any <i>lemma comments</i> are ignored.
</p>

<a id="string_piece" name="string_piece"></a>
<h2>7.3. Struct string_piece</h2>

<pre>
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string&amp; str);
}
</pre>

<p>
The <a href="#string_piece"><code>string_piece</code></a> is used for efficient string passing. The string
referenced in <a href="#string_piece"><code>string_piece</code></a> is not owned by it, so users have to make sure
the referenced string exists as long as the <a href="#string_piece"><code>string_piece</code></a>.
</p>

<a id="tagged_form" name="tagged_form"></a>
<h2>7.4. Struct tagged_form</h2>

<pre>
struct tagged_form {
  std::string form;
  std::string tag;
};
</pre>

<p>
The <a href="#tagged_form"><code>tagged_form</code></a> is a pair of strings used when obtaining a form and tag
pair.
</p>

<a id="tagged_lemma" name="tagged_lemma"></a>
<h2>7.5. Struct tagged_lemma</h2>

<pre>
struct tagged_lemma {
  std::string lemma;
  std::string tag;
};
</pre>

<p>
The <a href="#tagged_lemma"><code>tagged_lemma</code></a> is a pair of strings used when obtaining a lemma and tag
pair.
</p>

<a id="tagged_lemma_forms" name="tagged_lemma_forms"></a>
<h2>7.6. Struct tagged_lemma_forms</h2>

<pre>
struct tagged_lemma_forms {
  std::string lemma;
  std::vector&lt;<A HREF="#tagged_form">tagged_form</A>&gt; forms;
};
</pre>

<p>
The <a href="#tagged_lemma_forms"><code>tagged_lemma_forms</code></a> represents a lemma and a list of tagged forms.
</p>

<a id="token_range" name="token_range"></a>
<h2>7.7. Struct token_range</h2>

<pre>
struct token_range {
  size_t start;
  size_t length;
};
</pre>

<p>
The <a href="#token_range"><code>token_range</code></a> represent a range of a token as returned by a <a href="#tokenizer">tokenizer</a>.
The <code>start</code> and <code>length</code> fields specify the token position in Unicode
characters, not in bytes of UTF-8 encoding.
</p>

<a id="derivated_lemma" name="derivated_lemma"></a>
<h2>7.8. Struct derivated_lemma</h2>

<pre>
struct derivated_lemma {
  std::string lemma;
};
</pre>

<p>
The <a href="#derivated_lemma"><code>derivated_lemma</code></a> structure stores information about a derivation.
This information currently consists of lemma only, but a type of the derivation may
be added later.
</p>

<a id="version" name="version"></a>
<h2>7.9. Class version</h2>

<pre>
class version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;
  std::string prerelease;

  static <A HREF="#version">version</A> <A HREF="#version_current">current</A>();
};
</pre>

<p>
The <a href="#version"><code>version</code></a> class represents MorphoDiTa version.
See <a href="#versioning">MorphoDiTa Versioning</a> for more information.
</p>

<a id="version_current" name="version_current"></a>
<h3>7.9.1. version::current</h3>

<pre>
static <A HREF="#version">version</A> current();
</pre>

<p>
Returns current MorphoDiTa version.
</p>

<a id="tokenizer" name="tokenizer"></a>
<h2>7.10. Class tokenizer</h2>

<pre>
class tokenizer {
 public:
  virtual ~tokenizer() {}

  virtual void <A HREF="#tokenizer_set_text">set_text</A>(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
  virtual bool <A HREF="#tokenizer_next_sentence">next_sentence</A>(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;

  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_vertical_tokenizer">new_vertical_tokenizer</A>();
  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_czech_tokenizer">new_czech_tokenizer</A>();
  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_english_tokenizer">new_english_tokenizer</A>();
  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_generic_tokenizer">new_generic_tokenizer</A>();
};
</pre>

<p>
The <a href="#tokenizer"><code>tokenizer</code></a> class performs segmentation and tokenization of given text.
The class is <i>not</i> threadsafe.
</p>
<p>
The <a href="#tokenizer"><code>tokenizer</code></a> instances can be obtained either directly using
static methods or through instances of <a href="#morpho"><code>morpho</code></a> and <a href="#tagger"><code>tagger</code></a>.
</p>

<a id="tokenizer_set_text" name="tokenizer_set_text"></a>
<h3>7.10.1. tokenizer::set_text</h3>

<pre>
virtual void set_text(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
</pre>

<p>
Set the text which is to be tokenized.
</p>
<p>
If <code>make_copy</code> is <code>false</code>, only a reference to the given text is
stored and the user has to make sure it exists until the tokenizer
is released or <code>set_text</code> is called again. If <code>make_copy</code>
is <code>true</code>, a copy of the given text is made and retained until the
tokenizer is released or <code>set_text</code> is called again.
</p>

<a id="tokenizer_next_sentence" name="tokenizer_next_sentence"></a>
<h3>7.10.2. tokenizer::next_sentence</h3>

<pre>
virtual bool next_sentence(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;
</pre>

<p>
Locate and return next sentence of the given text. Returns <code>true</code> when successful and <code>false</code> when
there are no more sentences in the given text. The arguments are filled with found tokens if not <code>NULL</code>.
The <code>forms</code> contain token ranges in bytes of UTF-8 encoding, the <code>tokens</code> contain token ranges
in Unicode characters.
</p>

<a id="tokenizer_new_vertical_tokenizer" name="tokenizer_new_vertical_tokenizer"></a>
<h3>7.10.3. tokenizer::new_vertical_tokenizer</h3>

<pre>
static <A HREF="#tokenizer">tokenizer</A> new_vertical_tokenizer();
</pre>

<p>
Returns a new instance of a vertical tokenizer, which considers every line to
be one token, with empty line denoting end of sentence. The user should delete
the instance after use.
</p>

<a id="tokenizer_new_czech_tokenizer" name="tokenizer_new_czech_tokenizer"></a>
<h3>7.10.4. tokenizer::new_czech_tokenizer</h3>

<pre>
static <A HREF="#tokenizer">tokenizer</A> new_czech_tokenizer();
</pre>

<p>
Returns a new instance of a Czech tokenizer. The user should delete it after
use.
</p>
<p>
If two <a href="#versioning">MorphoDiTa versions</a> have the same <i>major.minor</i>, this
tokenizer should behave identically (apart from obvious bugfixes). Nevertheless,
the behaviour of this tokenizer might change in different <i>major.minor</i> version.
If you need a tokenizer whose behaviour does not change, use tokenizer embedded
in a morphological dictionary.
</p>

<a id="tokenizer_new_english_tokenizer" name="tokenizer_new_english_tokenizer"></a>
<h3>7.10.5. tokenizer::new_english_tokenizer</h3>

<pre>
static <A HREF="#tokenizer">tokenizer</A> new_english_tokenizer();
</pre>

<p>
Returns a new instance of a English tokenizer. The user should delete it after
use.
</p>
<p>
If two <a href="#versioning">MorphoDiTa versions</a> have the same <i>major.minor</i>, this
tokenizer should behave identically (apart from obvious bugfixes). Nevertheless,
the behaviour of this tokenizer might change in different <i>major.minor</i> version.
If you need a tokenizer whose behaviour does not change, use tokenizer embedded
in a morphological dictionary.
</p>

<a id="tokenizer_new_generic_tokenizer" name="tokenizer_new_generic_tokenizer"></a>
<h3>7.10.6. tokenizer::new_generic_tokenizer</h3>

<pre>
static <A HREF="#tokenizer">tokenizer</A> new_generic_tokenizer();
</pre>

<p>
Returns a new instance of a generic tokenizer. The user should delete it after
use.
</p>
<p>
If two <a href="#versioning">MorphoDiTa versions</a> have the same <i>major.minor</i>, this
tokenizer should behave identically (apart from obvious bugfixes). Nevertheless,
the behaviour of this tokenizer might change in different <i>major.minor</i> version.
If you need a tokenizer whose behaviour does not change, use tokenizer embedded
in a morphological dictionary.
</p>

<a id="derivator" name="derivator"></a>
<h2>7.11. Class derivator</h2>

<pre>
class derivator {
 public:
  virtual ~derivator();

  virtual bool <A HREF="#derivator_parent">parent</A>(<A HREF="#string_piece">string_piece</A> lemma, <A HREF="#derivated_lemma">derivated_lemma</A>&amp; parent) const = 0;
  virtual bool <A HREF="#derivator_children">children</A>(<A HREF="#string_piece">string_piece</A> lemma, std::vector&lt;<A HREF="#derivated_lemma">derivated_lemma</A>&gt;&amp; children) const = 0;
};
</pre>

<p>
The <a href="#derivator"><code>derivator</code></a> class perform morphological derivation on given lemmas.
The derivation are computed using lemma ids, see <a href="#lemma_structure">Lemma Structure</a>.
</p>
<p>
The <a href="#derivator"><code>derivator</code></a> instances can be obtained through instances of
<a href="#morpho"><code>morpho</code></a> (and transitively through <a href="#tagger"><code>tagger</code></a>).
</p>

<a id="derivator_parent" name="derivator_parent"></a>
<h3>7.11.1. derivator::parent</h3>

<pre>
virtual bool parent(<A HREF="#string_piece">string_piece</A> lemma, <A HREF="#derivated_lemma">derivated_lemma</A>&amp; parent) const = 0;
</pre>

<p>
Return the parent of a given lemma in the morphological derivation tree.
The lemma is assumed to be lemma id (see <a href="#lemma_structure">Lemma Structure</a>), so if it contains
any lemma comments, they are ignored.
</p>
<p>
The returned lemma is a full lemma (lemma id plus appropriate lemma comments).
</p>
<p>
If no parent exists, the function empties the parent lemma and returns <code>false</code>.
</p>

<a id="derivator_children" name="derivator_children"></a>
<h3>7.11.2. derivator::children</h3>

<pre>
virtual bool children(<A HREF="#string_piece">string_piece</A> lemma, std::vector&lt;<A HREF="#derivated_lemma">derivated_lemma</A>&gt;&amp; children) const = 0;
</pre>

<p>
Return children of a given lemma in the morphological derivation tree.
The lemma is assumed to be lemma id (see <a href="#lemma_structure">Lemma Structure</a>), so if it contains
any lemma comments, they are ignored.
</p>
<p>
The returned lemmas are full lemmas (lemma ids plus appropriate lemma comments).
</p>
<p>
If no children exist, the function empties the children vector and returns <code>false</code>.
</p>

<a id="derivation_formatter" name="derivation_formatter"></a>
<h2>7.12. Class derivation_formatter</h2>

<pre>
class derivation_formatter {
 public:
  virtual ~derivation_formatter() {}

  virtual void <A HREF="#derivation_formatter_format_derivation">format_derivation</A>(std::string&amp; lemma) const;
  virtual void <A HREF="#derivation_formatter_format_tagged_lemma">format_tagged_lemma</A>(<A HREF="#tagged_lemma">tagged_lemma</A>&amp; tagged_lemma, const <A HREF="#tagset_converter">tagset_converter</A>&amp; converter = nullptr) const = 0;
  virtual void <A HREF="#derivation_formatter_format_tagged_lemmas">format_tagged_lemmas</A>(std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tagged_lemmas, const <A HREF="#tagset_converter">tagset_converter</A>&amp; converter = nullptr) const = 0;

  static <A HREF="#derivation_formatter">derivation_formatter</A>* <A HREF="#derivation_formatter_new_none_derivation_formatter">new_none_derivation_formatter</A>();
  static <A HREF="#derivation_formatter">derivation_formatter</A>* <A HREF="#derivation_formatter_new_root_derivation_formatter">new_root_derivation_formatter</A>(const <A HREF="#derivator">derivator</A>* derinet);
  static <A HREF="#derivation_formatter">derivation_formatter</A>* <A HREF="#derivation_formatter_new_path_derivation_formatter">new_path_derivation_formatter</A>(const <A HREF="#derivator">derivator</A>* derinet);
  static <A HREF="#derivation_formatter">derivation_formatter</A>* <A HREF="#derivation_formatter_new_tree_derivation_formatter">new_tree_derivation_formatter</A>(const <A HREF="#derivator">derivator</A>* derinet);
  static <A HREF="#derivation_formatter">derivation_formatter</A>* <A HREF="#derivation_formatter_new_derivation_formatter">new_derivation_formatter</A>(<A HREF="#string_piece">string_piece</A> name, const <A HREF="#derivator">derivator</A>* derinet);
};
</pre>

<p>
The <a href="#derivation_formatter"><code>derivation_formatter</code></a> class performs required
morphological derivation and formats the results using a single string field
(i.e., directly in the lemma).
</p>

<a id="derivation_formatter_format_derivation" name="derivation_formatter_format_derivation"></a>
<h3>7.12.1. derivation_formatter::format_derivation</h3>

<pre>
virtual void format_derivation(std::string&amp; lemma) const;
</pre>

<p>
Perform the required morphological derivation and format the result back directly
in the lemma.
</p>

<a id="derivation_formatter_format_tagged_lemma" name="derivation_formatter_format_tagged_lemma"></a>
<h3>7.12.2. derivation_formatter::format_tagged_lemma</h3>

<pre>
virtual void format_tagged_lemma(<A HREF="#tagged_lemma">tagged_lemma</A>&amp; tagged_lemma, const <A HREF="#tagset_converter">tagset_converter</A>&amp; converter = nullptr) const = 0;
</pre>

<p>
Perform the required derivation and store it directly in the <a href="#tagged_lemma"><code>tagged_lemma</code></a>. If a <a href="#tagset_converter"><code>tagset_converter</code></a> is given, it is also applied.
</p>

<a id="derivation_formatter_format_tagged_lemmas" name="derivation_formatter_format_tagged_lemmas"></a>
<h3>7.12.3. derivation_formatter::format_tagged_lemmas</h3>

<pre>
virtual void format_tagged_lemmas(std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tagged_lemmas, const <A HREF="#tagset_converter">tagset_converter</A>&amp; converter = nullptr) const;
</pre>

<p>
Perform the required derivation on a list of <a href="#tagged_lemma"><code>tagged_lemma</code></a>s. If a <a href="#tagset_converter"><code>tagset_converter</code></a> is given, it is also applied. Either way, only unique entries are returned.
</p>

<a id="derivation_formatter_new_none_derivation_formatter" name="derivation_formatter_new_none_derivation_formatter"></a>
<h3>7.12.4. derivation_formatter::new_none_derivation_formatter</h3>

<pre>
static <A HREF="#derivation_formatter">derivation_formatter</A>* new_none_derivation_formatter();
</pre>

<p>
Return a new <a href="#derivation_formatter"><code>derivation_formatter</code></a> instance which does nothing
(i.e., it performs no derivation).
</p>

<a id="derivation_formatter_new_root_derivation_formatter" name="derivation_formatter_new_root_derivation_formatter"></a>
<h3>7.12.5. derivation_formatter::new_root_derivation_formatter</h3>

<pre>
static <A HREF="#derivation_formatter">derivation_formatter</A>* new_root_derivation_formatter(const <A HREF="#derivator">derivator</A>* derinet);
</pre>

<p>
Return a new <a href="#derivation_formatter"><code>derivation_formatter</code></a> instance which replaces
a lemma by the corresponding root in the derivation tree.
</p>

<a id="derivation_formatter_new_path_derivation_formatter" name="derivation_formatter_new_path_derivation_formatter"></a>
<h3>7.12.6. derivation_formatter::new_path_derivation_formatter</h3>

<pre>
static <A HREF="#derivation_formatter">derivation_formatter</A>* new_path_derivation_formatter(const <A HREF="#derivator">derivator</A>* derinet);
</pre>

<p>
Return a new <a href="#derivation_formatter"><code>derivation_formatter</code></a> instance which replaces
a lemma by a space separated path to the root in the morphological derivation tree (the original
lemma is first, followed by its parent, with the root being the last one).
</p>

<a id="derivation_formatter_new_tree_derivation_formatter" name="derivation_formatter_new_tree_derivation_formatter"></a>
<h3>7.12.7. derivation_formatter::new_tree_derivation_formatter</h3>

<pre>
static <A HREF="#derivation_formatter">derivation_formatter</A>* new_tree_derivation_formatter(const <A HREF="#derivator">derivator</A>* derinet);
</pre>

<p>
Return a new <a href="#derivation_formatter"><code>derivation_formatter</code></a> instance which appends
to the lemma the whole morphological derivation tree which contains it.
</p>
<p>
The tree is encoded in the following way: root node is the first, then the subtrees
of the root children are encoded recursively (each after one space), followed by a final
space (which denotes that the children are complete).
</p>

<a id="derivation_formatter_new_derivation_formatter" name="derivation_formatter_new_derivation_formatter"></a>
<h3>7.12.8. derivation_formatter::new_derivation_formatter</h3>

<pre>
static <A HREF="#derivation_formatter">derivation_formatter</A>* new_derivation_formatter(<A HREF="#string_piece">string_piece</A> name, const <A HREF="#derivator">derivator</A>* derinet);
</pre>

<p style="margin-bottom:0">
Return one of the available <a href="#derivation_formatter"><code>derivation_formatter</code></a> instances
according to the <code>name</code> parameter:
</p>
<ul style="margin-top:0">
<li><code>none</code>: return <a href="#derivation_formatter_new_none_derivation_formatter">new_none_derivation_formatter</a> instance
</li>
<li><code>root</code>: return <a href="#derivation_formatter_new_root_derivation_formatter">new_root_derivation_formatter</a> instance
</li>
<li><code>path</code>: return <a href="#derivation_formatter_new_path_derivation_formatter">new_path_derivation_formatter</a> instance
</li>
<li><code>tree</code>: return <a href="#derivation_formatter_new_tree_derivation_formatter">new_tree_derivation_formatter</a> instance
</li>
</ul>

<a id="morpho" name="morpho"></a>
<h2>7.13. Class morpho</h2>

<pre>
class morpho {
 public:
  virtual ~morpho() {}

  static <A HREF="#morpho">morpho</A>* <A HREF="#morpho_load_cstring">load</A>(const char* fname);
  static <A HREF="#morpho">morpho</A>* <A HREF="#morpho_load_istream">load</A>(istream&amp; is);

  enum <A HREF="#morpho_guesser_mode">guesser_mode</A> { NO_GUESSER = 0, GUESSER = 1, GUESSER_UNSPECIFIED = -1 };

  virtual int <A HREF="#morpho_analyze">analyze</A>(<A HREF="#string_piece">string_piece</A> form, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; lemmas) const = 0;
  virtual int <A HREF="#morpho_generate">generate</A>(<A HREF="#string_piece">string_piece</A> lemma, const char* tag_wildcard, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser, std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;

  virtual int <A HREF="#morpho_raw_lemma_len">raw_lemma_len</A>(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
  virtual int <A HREF="#morpho_lemma_id_len">lemma_id_len</A>(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
  virtual int <A HREF="#morpho_raw_form_len">raw_form_len</A>(<A HREF="#string_piece">string_piece</A> form) const = 0;

  virtual <A HREF="#tokenizer">tokenizer</A>* <A HREF="#morpho_new_tokenizer">new_tokenizer</A>() const = 0;

  virtual const <A HREF="#derivator">derivator</A>* <A HREF="#morpho_get_derivator">get_derivator</A>() const;
};
</pre>

<p>
A <a href="#morpho"><code>morpho</code></a> instance represents a morphological dictionary. Such a dictionary allow
morphological analysis, morphological generation provide information about lemma structure
and provides a suitable tokenizer. All methods are thread-safe.
</p>

<a id="morpho_load_cstring" name="morpho_load_cstring"></a>
<h3>7.13.1. morpho::load(const char*)</h3>

<pre>
static <A HREF="#morpho">morpho</A>* load(const char* fname);
</pre>

<p>
Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of <a href="#morpho"><code>morpho</code></a> which the user should delete
after use.
</p>

<a id="morpho_load_istream" name="morpho_load_istream"></a>
<h3>7.13.2. morpho::load(istream&amp;)</h3>

<pre>
static <A HREF="#morpho">morpho</A>* load(istream&amp; is);
</pre>

<p>
Factory method constructor. Accepts an input stream with the
model. Returns a pointer to an instance of <a href="#morpho"><code>morpho</code></a> which the user should
delete after use.
</p>

<a id="morpho_guesser_mode" name="morpho_guesser_mode"></a>
<h3>7.13.3. morpho::guesser_mode</h3>

<pre>
enum <A HREF="#morpho_guesser_mode">guesser_mode</A> { NO_GUESSER = 0, GUESSER = 1, GUESSER_UNSPECIFIED = -1 };
</pre>

<p>
Guesser mode defines behavior in case of unknown words. When set to
<code>GUESSER</code>, morpho tries to guess unknown words. When set to <code>NO_GUESSER</code>,
morpho does not guess unknown words.
</p>
<p style="margin-bottom:0">
The <code>GUESSER_UNSPECIFIED</code> mode denotes a default behaviour, which:
</p>
<ul style="margin-top:0">
<li>for <a href="#morpho"><code>morpho</code></a> means <code>NO_GUESSER</code>
</li>
<li>for <a href="#tagger"><code>tagger</code></a> means the default specified during tagger training
</li>
</ul>

<a id="morpho_analyze" name="morpho_analyze"></a>
<h3>7.13.4. morpho::analyze()</h3>

<pre>
virtual int analyze(<A HREF="#string_piece">string_piece</A> form, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; lemmas) const = 0;
</pre>

<p>
Perform morphological analysis of a form. The guesser parameter specifies whether
a guesser can be used if the form is not found in the dictionary. Output is
assigned to the lemmas vector.
</p>
<p>
If the form is found in the dictionary, analyses are assigned to lemmas
and <code>NO_GUESSER</code> returned. If <code>guesser == GUESSER</code> and the form analyses are
found using a guesser, they are assigned to lemmas and <code>GUESSER</code> is
returned.  Otherwise <code>-1</code> is returned and lemmas are filled with one
analysis containing given form as lemma and a tag for unknown word.
</p>

<a id="morpho_generate" name="morpho_generate"></a>
<h3>7.13.5. morpho::generate()</h3>

<pre>
virtual int generate(<A HREF="#string_piece">string_piece</A> lemmma, const char* tag_wildcard, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser, std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;
</pre>

<p>
Perform morphological generation of a lemma. Optionally a tag_wildcard can be
specified (or be <code>NULL</code>) and if so, results are filtered using this wildcard.
The guesser parameter speficies whether a guesser can be used if the lemma is
not found in the dictionary. Output is assigned to the forms vector.
</p>
<p>
Tag_wildcard can be either <code>NULL</code> or a wildcard applied to the results.
A <code>?</code> in the wildcard matches any character, <code>[bytes]</code> matches any of the
bytes and <code>[^bytes]</code> matches any byte different from the specified ones.
A <code>-</code> has no special meaning inside the bytes and if <code>]</code> is first in bytes,
it does not end the bytes group.
</p>
<p>
If the given lemma is only a raw lemma, all lemma ids with this raw lemma are
returned. Otherwise only matching lemma ids are returned, ignoring any lemma
comments. For every found lemma, matching forms are filtered using the
tag_wildcard. If at least one lemma is found in the dictionary, <code>NO_GUESSER</code>
is returned. If <code>guesser == GUESSER</code> and the lemma is found by the guesser,
<code>GUESSER</code> is returned. Otherwise, forms are cleared and <code>-1</code> is returned.
</p>

<a id="morpho_raw_lemma_len" name="morpho_raw_lemma_len"></a>
<h3>7.13.6. morpho::raw_lemma_len</h3>

<pre>
virtual int raw_lemma_len(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
</pre>

<p>
When given a lemma returned by the dictionary, returns the length of
a <i>raw lemma</i> (see <a href="#lemma_structure">Lemma Structure</a>).
</p>

<a id="morpho_lemma_id_len" name="morpho_lemma_id_len"></a>
<h3>7.13.7. morpho::lemma_id_len</h3>

<pre>
virtual int lemma_id_len(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
</pre>

<p>
When given a lemma returned by the dictionary, returns the length of
a <i>raw lemma</i> plus a <i>lemma id</i> (see <a href="#lemma_structure">Lemma Structure</a>).
Therefore, the substring of the original lemma of this length is a unique
lemma identifier. The rest of the original lemma are lemma comments which
do not identify the lemma.
</p>

<a id="morpho_raw_form_len" name="morpho_raw_form_len"></a>
<h3>7.13.8. morpho::raw_form_len</h3>

<pre>
virtual int raw_form_len(<A HREF="#string_piece">string_piece</A> form) const = 0;
</pre>

<p>
When given a form, returns the length of a <i>raw form</i>. This is used only in
<i>external morphology model</i>, where form contains also morphological analyses,
and this call can return the length of the form without the analyses.
</p>

<a id="morpho_new_tokenizer" name="morpho_new_tokenizer"></a>
<h3>7.13.9. morpho::new_tokenizer</h3>

<pre>
virtual <A HREF="#tokenizer">tokenizer</A>* new_tokenizer() const = 0;
</pre>

<p>
Returns a new instance of a suitable tokenizer or <code>NULL</code> if no such tokenizer
exists. The user should delete it after use.
</p>
<p>
Note that the tokenizer might use the <a href="#morpho"><code>morpho</code></a> instance, so the tokenizer
must not be used after the <a href="#morpho"><code>morpho</code></a> instance is destructed.
</p>

<a id="morpho_get_derivator" name="morpho_get_derivator"></a>
<h3>7.13.10. morpho::get_derivator</h3>

<pre>
virtual const <A HREF="#derivator">derivator</A>* get_derivator() const;
</pre>

<p>
Returns a <a href="#derivator"><code>derivator</code></a> for the morphology, or <code>NULL</code> if not available.
</p>
<p>
The <a href="#derivator"><code>derivator</code></a> is owned by the morphology, so the returned
instance should not be freed and it cannot be used after the <a href="#morpho"><code>morpho</code></a> instance
is destructed.
</p>

<a id="tagger" name="tagger"></a>
<h2>7.14. Class tagger</h2>

<pre>
class tagger {
 public:
  virtual ~tagger() {}

  static <A HREF="#tagger">tagger</A>* <A HREF="#tagger_load_cstring">load</A>(const char* fname);
  static <A HREF="#tagger">tagger</A>* <A HREF="#tagger_load_istream">load</A>(istream&amp; is);

  virtual const <A HREF="#morpho">morpho</A>* <A HREF="#tagger_get_morpho">get_morpho</A>() const = 0;

  virtual void <A HREF="#tagger_tag">tag</A>(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tags, <A HREF="#morpho">morpho</A>::<A HREF="#morpho_guesser_mode">guesser_mode</A> guesser = -1) const = 0;

  virtual void <A HREF="#tagger_tag_analyzed">tag_analyzed</A>(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt; &gt;&amp; analyses, std::vector&lt;int&gt;&amp; tags) const = 0;

  <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tagger_new_tokenizer">new_tokenizer</A>() const = 0;
};
</pre>

<p>
A <a href="#tagger"><code>tagger</code></a> instance represents a tagger, which perform disambiguation of
morphological analyses. All methods are thread-safe.
</p>

<a id="tagger_load_cstring" name="tagger_load_cstring"></a>
<h3>7.14.1. tagger::load(const char*)</h3>

<pre>
static <A HREF="#tagger">tagger</A>* load(const char* fname);
</pre>

<p>
Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of <a href="#tagger"><code>tagger</code></a> which the user should delete
after use.
</p>

<a id="tagger_load_istream" name="tagger_load_istream"></a>
<h3>7.14.2. tagger::load(istream&amp;)</h3>

<pre>
static <A HREF="#tagger">tagger</A>* load(istream&amp; is);
</pre>

<p>
Factory method constructor. Accepts an input stream with the
model. Returns a pointer to an instance of <a href="#tagger"><code>tagger</code></a> which the user should
delete after use.
</p>

<a id="tagger_get_morpho" name="tagger_get_morpho"></a>
<h3>7.14.3. tagger::get_morpho()</h3>

<pre>
virtual const <A HREF="#morpho">morpho</A>* get_morpho() const = 0;
</pre>

<p>
Returns a pointer to an instance of <a href="#morpho"><code>morpho</code></a> associated with the tagger. Do
not delete the pointer, it is owned by the tagger instance and deleted in the
tagger destructor.
</p>

<a id="tagger_tag" name="tagger_tag"></a>
<h3>7.14.4. tagger::tag()</h3>

<pre>
virtual void tag(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tags, <A HREF="#morpho">morpho</A>::<A HREF="#morpho_guesser_mode">guesser_mode</A> guesser = -1) const = 0;
</pre>

<p>
Perform morphological analysis and subsequent disambiguation. Accepts
a <code>std::vector</code> of <a href="#string_piece"><code>string_piece</code></a> and fills the output vector of <a href="#tagged_lemma"><code>tagged_lemma</code></a>.
</p>
<p>
The `guesser` parameter defines whether morphological guesser should be used.
If negative value is specified (which is the default), the guesser settings
employed when the tagger model was trained is used.
</p>

<a id="tagger_tag_analyzed" name="tagger_tag_analyzed"></a>
<h3>7.14.5. tagger::tag_analyzed()</h3>

<pre>
virtual void tag_analyzed(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt; &gt;&amp; analyses, std::vector&lt;int&gt;&amp; tags) const = 0;
</pre>

<p>
Perform morphological disambiguation using given morphological analyses.
The indices of chosen analyses are stored in the output vector <code>tags</code>.
</p>
<p>
None of the <code>analyses</code> can be empty &ndash; in that case, no operation is performed
and <code>tags</code> is empty. On the other hand, the <code>analyses</code> vector can be larger
than <code>forms</code> &ndash; additional entries are ignored in that case.
</p>
<p>
Note that the tagger was trained with a specific morphology &ndash; the more your
morphological analyses differ from the original ones, the worse the results
will be. One of the usages of <a href="#tagger_tag_analyzed"><code>tag_analyzed</code></a> is to
consider only a subset of morphological analyses.
</p>

<a id="tagger_new_tokenizer" name="tagger_new_tokenizer"></a>
<h3>7.14.6. tagger::new_tokenizer</h3>

<pre>
virtual <A HREF="#tokenizer">tokenizer</A>* new_tokenizer() const = 0;
</pre>

<p>
Returns a new instance of a suitable tokenizer or <code>NULL</code> if no such tokenizer
exists. The user should delete it after use.  The call is equal to
<code><A HREF="#tagger_get_morpho">get_morpho()</A>-&gt;<A HREF="#morpho_new_tokenizer">new_tokenizer()</A></code>.
</p>

<a id="tagset_converter" name="tagset_converter"></a>
<h2>7.15. Class tagset_converter</h2>

<pre>
class tagset_converter {
 public:
  virtual ~tagset_converter() {}

  virtual void <A HREF="#tagset_converter_convert">convert</A>(<A HREF="#tagged_lemma">tagged_lemma</A>&amp; tagged_lemma) const = 0;
  virtual void <A HREF="#tagset_converter_convert_analyzed">convert_analyzed</A>(std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tagged_lemmas) const = 0;
  virtual void <A HREF="#tagset_converter_convert_generated">convert_generated</A>(std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;

  static <A HREF="#tagset_converter">tagset_converter</A>* <A HREF="#tagset_converter_new_identity_converter">new_identity_converter</A>();
  static <A HREF="#tagset_converter">tagset_converter</A>* <A HREF="#tagset_converter_new_pdt_to_conll2009_converter">new_pdt_to_conll2009_converter</A>();
  static <A HREF="#tagset_converter">tagset_converter</A>* <A HREF="#tagset_converter_new_strip_lemma_comment_converter">new_strip_lemma_comment_converter</A>(const <A HREF="#morpho">morpho</A>&amp; dictionary);
  static <A HREF="#tagset_converter">tagset_converter</A>* <A HREF="#tagset_converter_new_strip_lemma_id_converter">new_strip_lemma_id_converter</A>(const <A HREF="#morpho">morpho</A>&amp; dictionary);
};
</pre>

<a id="tagset_converter_convert" name="tagset_converter_convert"></a>
<h3>7.15.1. tagset_converter::convert()</h3>

<pre>
virtual void convert(<A HREF="#tagged_lemma">tagged_lemma</A>&amp; tagged_lemma) const = 0;
</pre>

<p>
Convert the given tagged lemma.
</p>

<a id="tagset_converter_convert_analyzed" name="tagset_converter_convert_analyzed"></a>
<h3>7.15.2. tagset_converter::convert_analyzed()</h3>

<pre>
virtual void convert_analyzed(std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tagged_lemmas) const = 0;
</pre>

<p>
Convert the given results of <a href="#morpho_analyze">morpho::analyze</a>. Apart from calling
<a href="#tagset_converter_convert">convert</a>, any repeated entries are removed.
</p>

<a id="tagset_converter_convert_generated" name="tagset_converter_convert_generated"></a>
<h3>7.15.3. tagset_converter::convert_generated()</h3>

<pre>
virtual void convert_generated(std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;
</pre>

<p>
Convert the given results of <a href="#morpho_generate">morpho::generate</a>. Apart from calling
<a href="#tagset_converter_convert">convert</a>, any repeated entries are removed.
</p>

<a id="tagset_converter_new_identity_converter" name="tagset_converter_new_identity_converter"></a>
<h3>7.15.4. tagset_converter::new_identity_converter()</h3>

<pre>
static <A HREF="#tagset_converter">tagset_converter</A>* new_identity_converter();
</pre>

<p>
Returns a new instance of an identity converter. All convert methods of an
identity converter do nothing. The user should delete the instance after use.
</p>

<a id="tagset_converter_new_pdt_to_conll2009_converter" name="tagset_converter_new_pdt_to_conll2009_converter"></a>
<h3>7.15.5. tagset_converter::new_pdt_to_conll2009_converter()</h3>

<pre>
static <A HREF="#tagset_converter">tagset_converter</A>* new_pdt_to_conll2009_converter();
</pre>

<p>
Returns a new instance of a Czech PDT tag set to CoNLL2009 tag set converter.
The user should delete the instance after use.
</p>
<p>
CoNLL2009 tag set uses two columns for tags &ndash; one is a POS and the other one
are additional FEATs. Because we have only one tag field, we merge these fields
together by using <code>Pos=?|FEAT</code>, i.e., the POS is stored as a first FEAT.
</p>

<a id="tagset_converter_new_strip_lemma_comment_converter" name="tagset_converter_new_strip_lemma_comment_converter"></a>
<h3>7.15.6. tagset_converter::new_strip_lemma_comment_converter()</h3>

<pre>
static <A HREF="#tagset_converter">tagset_converter</A>* new_strip_lemma_comment_converter(const <A HREF="#morpho">morpho</A>&amp; dictionary);
</pre>

<p>
Returns a new instance of a tag set converter stripping
<a href="#lemma_structure">lemma comment</a> using the given <a href="#morpho"><code>morpho</code></a> instance,
which must remain valid during existence of the tag set converter. The user
should delete the tag set converter instance after use.
</p>

<a id="tagset_converter_new_strip_lemma_id_converter" name="tagset_converter_new_strip_lemma_id_converter"></a>
<h3>7.15.7. tagset_converter::new_strip_lemma_id_converter()</h3>

<pre>
static <A HREF="#tagset_converter">tagset_converter</A>* new_strip_lemma_id_converter(const <A HREF="#morpho">morpho</A>&amp; dictionary);
</pre>

<p>
Returns a new instance of a tag set converter stripping
<a href="#lemma_structure">lemma id</a> using the given <a href="#morpho"><code>morpho</code></a> instance,
which must remain valid during existence of the tag set converter. The user
should delete the tag set converter instance after use.
</p>

<a id="cpp_bindings_api" name="cpp_bindings_api"></a>
<h2>7.16. C++ Bindings API</h2>

<p>
Bindings for other languages than C++ are created using SWIG from the C++
bindings API, which is a slightly modified version of the native C++ API.
Main changes are replacement of <a href="#string_piece"><code>string_piece</code></a> type by native
strings and removal of methods using <code>istream</code>. Here is the C++ bindings API
declaration:
</p>

<a id="bindings_helper_structures" name="bindings_helper_structures"></a>
<h3>7.16.1. Helper Structures</h3>

<pre>
typedef vector&lt;int&gt; Indices;

typedef vector&lt;string&gt; Forms;

struct TaggedForm {
  string form;
  string tag;
};
typedef vector&lt;TaggedForm&gt; TaggedForms;

struct TaggedLemma {
  string lemma;
  string tag;
};
typedef vector&lt;TaggedLemma&gt; TaggedLemmas;
typedef vector&lt;TaggedLemmas&gt; Analyses;

struct TaggedLemmaForms {
  string lemma;
  TaggedForms forms;
};
typedef vector&lt;TaggedLemmaForms&gt; TaggedLemmasForms;

struct TokenRange {
  size_t start;
  size_t length;
};
typedef vector&lt;TokenRange&gt; TokenRanges;

struct DerivatedLemma {
  std::string lemma;
};
typedef vector&lt;DerivatedLemma&gt; DerivatedLemmas;
</pre>

<a id="bindings_main_classes" name="bindings_main_classes"></a>
<h3>7.16.2. Main Classes</h3>

<pre>
class Version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;
  string prerelease;

  static Version current();
};

class Tokenizer {
 public:
  virtual void setText(const char* text);
  virtual bool nextSentence(Forms* forms, TokenRanges* tokens);

  static Tokenizer* newVerticalTokenizer();
  static Tokenizer* newCzechTokenizer();
  static Tokenizer* newEnglishTokenizer();
  static Tokenizer* newGenericTokenizer();
};

class TagsetConverter {
 public:
  static TagsetConverter* newIdentityConverter();
  static TagsetConverter* newPdtToConll2009Converter();
  static TagsetConverter* newStripLemmaCommentConverter(const Morpho&amp; morpho);
  static TagsetConverter* newStripLemmaIdConverter(const Morpho&amp; morpho);

  virtual void convert(TaggedLemma&amp; lemma) const;
  virtual void convertAnalyzed(TaggedLemmas&amp; lemmas) const;
  virtual void convertGenerated(TaggedLemmasForms&amp; forms) const;
};

class Derivator {
 public:
  virtual bool parent(const char* lemma, DerivatedLemma&amp; parent) const;
  virtual bool children(const char* lemma, DerivatedLemmas&amp; children) const;
};

class DerivationFormatter {
 public:
  virtual string formatDerivation(const char* lemma) const;
  virtual void formatTaggedLemma(TaggedLemma&amp; tagged_lemma, const TagsetConverter* converter = nullptr) const;
  virtual void formatTaggedLemmas(TaggedLemmas&amp; tagged_lemma, const TagsetConverter* converter = nullptr) const;

  static DerivationFormatter* newNoneDerivationFormatter();
  static DerivationFormatter* newRootDerivationFormatter(const Derivator* derivator);
  static DerivationFormatter* newPathDerivationFormatter(const Derivator* derivator);
  static DerivationFormatter* newTreeDerivationFormatter(const Derivator* derivator);
  static DerivationFormatter* newDerivationFormatter(const char* name, const Derivator* derivator);
};

class Morpho {
 public:
  static Morpho* load(const char* fname);

  enum { NO_GUESSER = 0, GUESSER = 1, GUESSER_UNSPECIFIED = -1 };

  virtual int analyze(const char* form, int guesser, TaggedLemmas&amp; lemmas) const;
  virtual int generate(const char* lemma, const char* tag_wildcard, int guesser, TaggedLemmasForms&amp; forms) const;
  virtual string rawLemma(const char* lemma) const;
  virtual string lemmaId(const char* lemma) const;
  virtual string rawForm(const char* form) const;

  virtual Tokenizer* newTokenizer() const;

  virtual Derivator* getDerivator() const;
};

class Tagger {
 public:
  static Tagger* load(const char* fname);

  virtual const Morpho* getMorpho() const;

  virtual void tag(const Forms&amp; forms, TaggedLemmas&amp; tags, int guesser = Morpho::GUESSER_UNSPECIFIED) const;

  virtual void tagAnalyzed(const Forms&amp; forms, const Analyses&amp; analyses, Indices&amp; tags) const;

  Tokenizer* newTokenizer() const;
};
</pre>

<a id="csharp_bindings" name="csharp_bindings"></a>
<h2>7.17. C# Bindings</h2>

<p>
MorphoDiTa library bindings is available in the <code>Ufal.MorphoDiTa</code> namespace.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
The bindings requires native C++ library <code>libmorphodita_csharp</code> (called
<code>morphodita_csharp</code> on Windows).
</p>

<a id="java_bindings" name="java_bindings"></a>
<h2>7.18. Java Bindings</h2>

<p>
MorphoDiTa library bindings is available in the <code>cz.cuni.mff.ufal.morphodita</code>
package.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
Vectors do not have native Java interface, see
<code>cz.cuni.mff.ufal.morphodita.Forms</code> class for reference. Also, class members
are accessible and modifiable using using <code>getField</code> and <code>setField</code>
wrappers.
</p>
<p>
The bindings require native C++ library <code>libmorphodita_java</code> (called
<code>morphodita_java</code> on Windows). If the library is found in the current
directory, it is used, otherwise standard library search process is used.
The path to the C++ library can also be specified using static
<code>morphodita_java.setLibraryPath(String path)</code> call (before the first call
inside the C++ library, of course).
</p>

<a id="perl_bindings" name="perl_bindings"></a>
<h2>7.19. Perl Bindings</h2>

<p>
MorphoDiTa library bindings is available in the
<a href="http://search.cpan.org/~straka/Ufal-MorphoDiTa/"><code>Ufal::MorphoDiTa</code></a> package.
The classes can be imported into the current namespace using the <code>:all</code>
export tag.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
Vectors do not have native Perl interface, see <code>Ufal::MorphoDiTa::Forms</code> for
reference. Static methods and enumerations are available only through the
module, not through object instance.
</p>

<a id="python_bindings" name="python_bindings"></a>
<h2>7.20. Python Bindings</h2>

<p>
MorphoDiTa library bindings is available in the
<a href="http://pypi.python.org/pypi/ufal.morphodita"><code>ufal.morphodita</code></a> module,
with binary wheels provided for Linux, Windows and OS X.
</p>
<p>
The bindings is a straightforward conversion of the <code>C++</code> bindings API.
Only Python &gt;=3 is supported.
</p>

<a id="contact" name="contact"></a>
<h1>8. Contact</h1>

<p style="margin-bottom:0">
Authors:
</p>
<ul style="margin-top:0">
<li><a href="http://ufal.mff.cuni.cz/milan-straka">Milan Straka</a>, <a href="mailto:straka@ufal.mff.cuni.cz">straka@ufal.mff.cuni.cz</a>
</li>
<li><a href="http://ufal.mff.cuni.cz/jana-strakova">Jana Straková</a>, <a href="mailto:strakova@ufal.mff.cuni.cz">strakova@ufal.mff.cuni.cz</a>
</li>
</ul>

<p>
<a href="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa website</a>.
</p>
<p>
<a href="http://hdl.handle.net/11858/00-097C-0000-0023-43CD-0">MorphoDiTa LINDAT/CLARIN entry</a>.
</p>

<a id="morphodita_acknowledgements" name="morphodita_acknowledgements"></a>
<h1>9. Acknowledgements</h1>

<p>
This work has been using language resources developed and/or stored and/or distributed by the LINDAT/CLARIN project of the Ministry of Education of the Czech Republic (project <i>LM2010013</i>).
</p>
<p>
Acknowledgements for individual language models are listed in <a href="#users_manual">MorphoDiTa User's Manual</a>.
</p>

<a id="publications" name="publications"></a>
<h2>9.1. Publications</h2>

<ul>
<li>(Straková et al. 2014) Straková Jana, Straka Milan and Hajič Jan. <i><a href="http://www.aclweb.org/anthology/P/P14/P14-5003.pdf">Open-Source Tools for Morphology, Lemmatization, POS Tagging and Named Entity Recognition.</a></i> In Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations, pages 13-18, Baltimore, Maryland, June 2014. Association for Computational Linguistics.
<p></p>
</li>
<li>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <i><a href="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</a></i> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
</li>
</ul>

<a id="bibtex_for_referencing" name="bibtex_for_referencing"></a>
<h2>9.2. Bibtex for Referencing</h2>

<pre>
@InProceedings{strakova14,
  author    = {Strakov\'{a}, Jana  and  Straka, Milan  and  Haji\v{c}, Jan},
  title     = {Open-{S}ource {T}ools for {M}orphology, {L}emmatization, {POS} {T}agging and {N}amed {E}ntity {R}ecognition},
  booktitle = {Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations},
  month     = {June},
  year      = {2014},
  address   = {Baltimore, Maryland},
  publisher = {Association for Computational Linguistics},
  pages     = {13--18},
  url       = {http://www.aclweb.org/anthology/P/P14/P14-5003.pdf}
}
</pre>

<a id="persistent_identifier" name="persistent_identifier"></a>
<h2>9.3. Persistent Identifier</h2>

<p>
If you prefer to reference MorphoDiTa by a persistent identifier (PID),
you can use <code>http://hdl.handle.net/11858/00-097C-0000-0023-43CD-0</code>.
</p>
</div>

<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -\-toc -\-enum-title -o morphodita.html -C t2t_docsys/t2t_docsys_manual.conf morphodita.t2t -->
</body></html>
