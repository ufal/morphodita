<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<TITLE>MorphoDiTa: Morphological Dictionary and Tagger</TITLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>MorphoDiTa: Morphological Dictionary and Tagger</H1>
<H2>Version 1.0.1</H2>
</DIV>

<DIV CLASS="toc">

  <OL>
  <LI><A HREF="#toc1">Introduction</A>
  <LI><A HREF="#toc2">Release</A>
    <UL>
    <LI><A HREF="#toc3">2.1. Download</A>
      <UL>
      <LI><A HREF="#language_models">2.1.1. Language Models</A>
      </UL>
    <LI><A HREF="#toc5">2.2. License</A>
    <LI><A HREF="#toc6">2.3. Platforms and Requirements</A>
    </UL>
  <LI><A HREF="#toc7">MorphoDiTa Installation</A>
    <UL>
    <LI><A HREF="#toc8">3.1. Requirements</A>
    <LI><A HREF="#toc9">3.2. Compilation</A>
      <UL>
      <LI><A HREF="#toc10">3.2.1. Windows</A>
      </UL>
    <LI><A HREF="#toc11">3.3. Other language bindings</A>
      <UL>
      <LI><A HREF="#toc12">3.3.1. Java</A>
      <LI><A HREF="#toc13">3.3.2. Perl</A>
      <LI><A HREF="#toc14">3.3.3. Python</A>
      </UL>
    </UL>
  <LI><A HREF="#toc15">MorphoDiTa User's Manual</A>
    <UL>
    <LI><A HREF="#czech-morfflex-pdt">4.1. Czech MorphoDiTa Models</A>
      <UL>
      <LI><A HREF="#czech-morfflex-pdt_acknowledgements">4.1.1. Acknowledgements</A>
      <LI><A HREF="#czech_morphological_system">4.1.2. Czech Morphological System</A>
      <LI><A HREF="#toc19">4.1.3. Main Czech Model</A>
      <LI><A HREF="#toc20">4.1.4. Part of Speech Only Variant</A>
      <LI><A HREF="#toc21">4.1.5. Raw Lemmas Variant</A>
      </UL>
    <LI><A HREF="#english-morphium-wsj">4.2. English MorphoDiTa Models</A>
      <UL>
      <LI><A HREF="#english-morphium-wsj_acknowledgements">4.2.1. Acknowledgements</A>
      <LI><A HREF="#toc24">4.2.2. English Morphological System</A>
      <LI><A HREF="#toc25">4.2.3. English Model</A>
      <LI><A HREF="#toc26">4.2.4. No Negations Variant</A>
      <LI><A HREF="#toc27">4.2.5. English Model Changes</A>
      </UL>
    <LI><A HREF="#run_tagger">4.3. Running the Tagger</A>
      <UL>
      <LI><A HREF="#toc29">4.3.1. Input Formats</A>
      <LI><A HREF="#toc30">4.3.2. Tag Set Conversion</A>
      <LI><A HREF="#toc31">4.3.3. Output Formats</A>
      </UL>
    <LI><A HREF="#toc32">4.4. Running the Morphology</A>
      <UL>
      <LI><A HREF="#run_morpho_analyze">4.4.1. Morphological Analysis</A>
      <LI><A HREF="#run_morpho_generate">4.4.2. Morphological Generation</A>
      <LI><A HREF="#run_morpho_cli">4.4.3. Interactive Morphological Analysis and Generation</A>
      </UL>
    <LI><A HREF="#run_tokenizer">4.5. Running the Tokenizer</A>
      <UL>
      <LI><A HREF="#toc37">4.5.1. Output Formats</A>
      </UL>
    <LI><A HREF="#custom_models">4.6. Custom Morphological and Tagging Models</A>
      <UL>
      <LI><A HREF="#toc39">4.6.1. Custom Morphological Models</A>
      <LI><A HREF="#toc40">4.6.2. Custom Tagging Models</A>
      </UL>
    </UL>
  <LI><A HREF="#toc41">MorphoDiTa API Tutorial</A>
    <UL>
    <LI><A HREF="#toc42">5.1. Tagger API</A>
    <LI><A HREF="#toc43">5.2. Morphological Dictionary API</A>
      <UL>
      <LI><A HREF="#toc44">5.2.1. Dictionary Construction</A>
      <LI><A HREF="#toc45">5.2.2. Morphological Analysis</A>
      <LI><A HREF="#toc46">5.2.3. Generation</A>
      </UL>
    <LI><A HREF="#faq">5.3. Questions and Answers</A>
    </UL>
  <LI><A HREF="#toc48">MorphoDiTa API Reference</A>
    <UL>
    <LI><A HREF="#versioning">6.1. MorphoDiTa Versioning</A>
    <LI><A HREF="#lemma_structure">6.2. Lemma Structure</A>
    <LI><A HREF="#string_piece">6.3. Struct string_piece</A>
    <LI><A HREF="#tagged_form">6.4. Struct tagged_form</A>
    <LI><A HREF="#tagged_lemma">6.5. Struct tagged_lemma</A>
    <LI><A HREF="#tagged_lemma_forms">6.6. Struct tagged_lemma_forms</A>
    <LI><A HREF="#token_range">6.7. Struct token_range</A>
    <LI><A HREF="#version">6.8. Class version</A>
      <UL>
      <LI><A HREF="#version_current">6.8.1. version::current</A>
      </UL>
    <LI><A HREF="#tokenizer">6.9. Class tokenizer</A>
      <UL>
      <LI><A HREF="#tokenizer_set_text">6.9.1. tokenizer::set_text</A>
      <LI><A HREF="#tokenizer_next_sentence">6.9.2. tokenizer::next_sentence</A>
      <LI><A HREF="#tokenizer_new_vertical_tokenizer">6.9.3. tokenizer::new_vertical_tokenizer</A>
      <LI><A HREF="#tokenizer_new_czech_tokenizer">6.9.4. tokenizer::new_czech_tokenizer</A>
      <LI><A HREF="#tokenizer_new_english_tokenizer">6.9.5. tokenizer::new_english_tokenizer</A>
      <LI><A HREF="#tokenizer_new_generic_tokenizer">6.9.6. tokenizer::new_generic_tokenizer</A>
      </UL>
    <LI><A HREF="#morpho">6.10. Class morpho</A>
      <UL>
      <LI><A HREF="#morpho_load_cstring">6.10.1. morpho::load(const char*)</A>
      <LI><A HREF="#morpho_load_FILE">6.10.2. morpho::load(FILE*)</A>
      <LI><A HREF="#morpho_guesser_mode">6.10.3. morpho::guesser_mode</A>
      <LI><A HREF="#morpho_analyze">6.10.4. morpho::analyze()</A>
      <LI><A HREF="#morpho_generate">6.10.5. morpho::generate()</A>
      <LI><A HREF="#morpho_raw_lemma_len">6.10.6. morpho::raw_lemma_len</A>
      <LI><A HREF="#morpho_lemma_id_len">6.10.7. morpho::lemma_id_len</A>
      <LI><A HREF="#morpho_raw_form_len">6.10.8. morpho::raw_form_len</A>
      <LI><A HREF="#morpho_new_tokenizer">6.10.9. morpho::new_tokenizer</A>
      </UL>
    <LI><A HREF="#tagger">6.11. Class tagger</A>
      <UL>
      <LI><A HREF="#tagger_load_cstring">6.11.1. tagger::load(const char*)</A>
      <LI><A HREF="#tagger_load_FILE">6.11.2. tagger::load(FILE*)</A>
      <LI><A HREF="#tagger_get_morpho">6.11.3. tagger::get_morpho()</A>
      <LI><A HREF="#tagger_tag">6.11.4. tagger::tag()</A>
      <LI><A HREF="#tagger_new_tokenizer">6.11.5. tagger::new_tokenizer</A>
      </UL>
    <LI><A HREF="#tagset_converter">6.12. Class tagset_converter</A>
      <UL>
      <LI><A HREF="#tagset_converter_convert">6.12.1. tagset_converter::convert()</A>
      <LI><A HREF="#tagset_converter_convert_analyzed">6.12.2. tagset_converter::convert_analyzed()</A>
      <LI><A HREF="#tagset_converter_convert_generated">6.12.3. tagset_converter::convert_generated()</A>
      <LI><A HREF="#tagset_converter_new_identity_converter">6.12.4. tagset_converter::new_identity_converter()</A>
      <LI><A HREF="#tagset_converter_new_pdt_to_conll2009_converter">6.12.5. tagset_converter::new_pdt_to_conll2009_converter()</A>
      </UL>
    <LI><A HREF="#toc87">6.13. C++ Bindings API</A>
      <UL>
      <LI><A HREF="#toc88">6.13.1. Helper Structures</A>
      <LI><A HREF="#toc89">6.13.2. Main Classes</A>
      </UL>
    <LI><A HREF="#toc90">6.14. Java Bindings</A>
    <LI><A HREF="#toc91">6.15. Perl Bindings</A>
    <LI><A HREF="#toc92">6.16. Python Bindings</A>
    </UL>
  <LI><A HREF="#toc93">Contact</A>
  <LI><A HREF="#morphodita_acknowledgements">Acknowledgements</A>
    <UL>
    <LI><A HREF="#toc95">8.1. Publications</A>
    <LI><A HREF="#toc96">8.2. Bibtex for referencing</A>
    </UL>
  </OL>

</DIV>
<DIV CLASS="body" ID="body">

<A NAME="toc1"></A>
<H1>1. Introduction</H1>

<P>
MorphoDiTa: Morphological Dictionary and Tagger is an open-source tool for
morphological analysis of natural language texts. It performs morphological
analysis, morphological generation, tagging and tokenization and is distributed
as a standalone tool or a library, along with trained linguistic models. In the
Czech language, MorphoDiTa achieves state-of-the-art results with a throughput
around 10-200K words per second. MorphoDiTa is a free software under
<A HREF="http://www.gnu.org/licenses/lgpl.html">LGPL</A> license and the linguistic models
are free for non-commercial use and distributed under
<A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A> license, although for some
models the original data used to create the model may impose additional
licensing conditions.
</P>
<P>
Copyright 2014 by Institute of Formal and Applied Linguistics, Faculty of
Mathematics and Physics, Charles University in Prague, Czech Republic.
</P>

<A NAME="toc2"></A>
<H1>2. Release</H1>

<A NAME="toc3"></A>
<H2>2.1. Download</H2>

<P>
MorphoDiTa releases are available on <A HREF="http://github.com/ufal/morphodita">GitHub</A>, either as
a pre-compiled binary package, or source code only. The binary package contains Linux
and Windows binaries and <CODE>C++</CODE> library, all language bindings (Java, Python, Perl)
and source code (needed to compile the language bindings).
</P>

<UL>
<LI><A HREF="http://github.com/ufal/morphodita/releases/latest">Latest release</A>
<LI><A HREF="http://github.com/ufal/morphodita/releases">All releases</A>
</UL>

<A NAME="language_models"></A>
<H3>2.1.1. Language Models</H3>

<P>
To use MorphoDiTa, a language model is needed. The language models are available
from <A HREF="http://www.lindat.cz">LINDAT/CLARIN</A> infrastructure and described further
in the User's Manual. Currently the following language models are available:
</P>

<UL>
<LI>Czech: <A HREF="http://hdl.handle.net/11858/00-097C-0000-0023-68D8-1">czech-morfflex-pdt-131112</A>
<LI>English: <A HREF="http://hdl.handle.net/11858/00-097C-0000-0023-68D9-0">english-morphium-wsj-140407</A>
</UL>

<A NAME="toc5"></A>
<H2>2.2. License</H2>

<P>
MorphoDiTa is an open-source project and is freely available for non-commercial
purposes. The library is distributed under
<A HREF="http://www.gnu.org/licenses/lgpl.html">LGPL</A> and the associated models and data
under <A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A>, although
for some models the original data used to create the model may impose
additional licensing conditions.
</P>
<P>
If you use this tool for scientific work, please give credit to us by
referencing <A HREF="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa website</A> and
<A HREF="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Spoustová et al. 2009</A>.
</P>

<A NAME="toc6"></A>
<H2>2.3. Platforms and Requirements</H2>

<P>
MorphoDiTa is available as a standalone tool and as a library for Linux/Windows. It does not require any additional libraries. As any supervised machine learning tool, it needs trained linguistic models to perform morphological analysis. The models for the Czech language are available with the tool.
</P>

<A NAME="toc7"></A>
<H1>3. MorphoDiTa Installation</H1>

<P>
MorphoDiTa releases are available on <A HREF="http://github.com/ufal/morphodita">GitHub</A>, either as
a pre-compiled binary package, or source code only. The binary package contains Linux
and Windows binaries, <CODE>C++</CODE> library binary, Java bindings binary, and source code of
all language bindings (Java, Python, Perl) and MorphoDiTa. While the binary
packages do not contain compiled Python or Perl bindings, packages for those
languages are available in standard package repositories, i.e. on PyPI and CPAN.
</P>
<P>
To use MorphoDiTa, a language model is needed.
<A HREF="http://ufal.mff.cuni.cz/morphodita#language_models">Here is a list of available language models</A>.
</P>
<P>
If you want to compile MorphoDiTa manually, sources are available on on
<A HREF="http://github.com/ufal/morphodita">GitHub</A>, both in the
<A HREF="http://github.com/ufal/morphodita/releases">pre-compiled binary package releases</A>
and in the repository itself.
</P>

<A NAME="toc8"></A>
<H2>3.1. Requirements</H2>

<UL>
<LI><CODE>G++ 4.7</CODE> or newer, alternatively <CODE>clang 3.2</CODE> or newer
<LI><CODE>make</CODE>
<LI><CODE>SWIG 2.0.5</CODE> or newer for language bindings other than <CODE>C++</CODE>
</UL>

<A NAME="toc9"></A>
<H2>3.2. Compilation</H2>

<P>
To compile MorphoDiTa on Unix-like systems, run <CODE>make</CODE> in the <CODE>src</CODE> directory.
</P>
<P>
Make targets and options:
</P>

<UL>
<LI><CODE>exe</CODE>: compile the binaries (default)
<LI><CODE>lib</CODE>: compile the library
<LI><CODE>BITS=32</CODE> or <CODE>BITS=64</CODE>: compile for specified 32-bit or 64-bit architecture instead of the default one
<LI><CODE>RELEASE=1</CODE>: turn off assertions and use LTO
<LI><CODE>PROFILE=1</CODE>: turn on profiling
<LI><CODE>DEBUG=1</CODE>: compile with debug informations and C++ library debugging
</UL>

<A NAME="toc10"></A>
<H3>3.2.1. Windows</H3>

<P>
Currently only G++ is supported under Windows. We use
<A HREF="http://tdm-gcc.tdragon.net/">TDM-GCC</A> for producing Windows builds,
but MinGW and Cygwin are also known to work. If you are interested in adding
support for other compilers (most notably, Visual Studio), let us know.
</P>
<P>
By default, Unix-like shell is required (i.e., Cygwin or MSYS). If you use
standard Windows Cmd.exe (i.e., TDM-GCC or plain MinGW), use
</P>

<PRE>
make WINCMD=1
</PRE>

<P>
Note that <CODE>make</CODE> in MinGW is usually distributed as <CODE>mingw32-make</CODE>.
</P>

<A NAME="toc11"></A>
<H2>3.3. Other language bindings</H2>

<A NAME="toc12"></A>
<H3>3.3.1. Java</H3>

<P>
Binary Java bindings are available in MorphoDiTa binary packages.
</P>
<P>
To compile Java bindings manually, run <CODE>make</CODE> in the <CODE>bindings/java</CODE>
directory, optionally with the options descriged in MorphoDiTa Installation.
Java 6 and newer is supported.
</P>
<P>
The Java installation specified in the environment variable <CODE>JAVA_HOME</CODE> is
used.  If the environment variable does not exist, the <CODE>JAVA_HOME</CODE> can be
specified using
</P>

<PRE>
make JAVA_HOME=path_to_Java_installation
</PRE>

<A NAME="toc13"></A>
<H3>3.3.2. Perl</H3>

<P>
The Perl bindings are available as <CODE>Ufal-MorphoDiTa</CODE> package on CPAN.
</P>
<P>
To compile Perl bindings manually, run <CODE>make</CODE> in the <CODE>bindings/perl</CODE>
directory, optionally with the options descriged in MorphoDiTa Installation.
Perl 5.10 and later is supported.
</P>
<P>
Path to the include headers of the required Perl version must be specified
in the <CODE>PERL_INCLUDE</CODE> variable using
</P>

<PRE>
make PERL_INCLUDE=path_to_Perl_includes
</PRE>

<A NAME="toc14"></A>
<H3>3.3.3. Python</H3>

<P>
The Python bindings are available as <CODE>ufal.morphodita</CODE> package on PyPI.
</P>
<P>
To compile Python bindings manually, run <CODE>make</CODE> in the <CODE>bindings/python</CODE>
directory, optionally with options descriged in MorphoDiTa Installation. Both
Python 2.6+ and Python 3+ are supported.
</P>
<P>
Path to the include headers of the required Python version must be specified
in the <CODE>PYTHON_INCLUDE</CODE> variable using
</P>

<PRE>
make PYTHON_INCLUDE=path_to_Python_includes
</PRE>

<A NAME="toc15"></A>
<H1>4. MorphoDiTa User's Manual</H1>

<P>
In a natural language text, the task of morphological analysis is to assign for
each token (word) in a sentence its lemma (cannonical form) and
a part-of-speech tag (POS tag). This is usually achieved in two steps:
a morphological dictionary looks up all possible lemmas and POS tags for each
word, and subsequently, a morphological tagger picks for each word the best
lemma-POS tag candidate. The second task is called a disambiguation.
</P>
<P>
MorphoDiTa also performs these two steps of morphological analysis: It first
outputs all possible pairs of lemma and POS tag for each token. Consequently,
the optimal combination of lemmas and POS tags is selected for the words in
a sentence using an algorithm described in
<A HREF="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Spoustová et al. 2009</A>.
</P>
<P>
Like any supervised machine learning tool, MorphoDiTa needs a trained linguistic model.
This section describes the available language models and also the commandline
tools and interfaces. The C++ library is described elsewhere, either in
MorphoDiTa API Tutorial or in MorphoDiTa API Reference.
</P>

<A NAME="czech-morfflex-pdt"></A>
<H2>4.1. Czech MorphoDiTa Models</H2>

<P>
Czech models are distributed under the
<A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A> licence.
The Czech morphology uses the
<A HREF="http://hdl.handle.net/11858/00-097C-0000-0015-A780-9">MorfFlex CZ</A>
Czech morphological dictionary and the Czech tagger is trained on
<A HREF="http://ufal.mff.cuni.cz/pdt2.5/">PDT 2.5</A>. Czech models work in MorphoDiTa
version 1.0 or later.
</P>
<P>
Apart from MorfFlex CZ dictionary, a prefix guesser and statistical guesser
are implemented and can be optionally used when performing morphological analysis.
</P>
<P>
Czech models are versioned according to the version of the MorfFlex CZ
morphological dictionary used, the version format is <CODE>YYMMDD</CODE>, where <CODE>YY</CODE>,
<CODE>MM</CODE> and <CODE>DD</CODE> are two-digit representation of year, month and day,
respectively. The latest version is 131112.
</P>
<P>
Compared to Featurama <A HREF="http://sourceforge.net/projects/featurama/">http://sourceforge.net/projects/featurama/</A>
(state-of-the-art Czech tagger implementation), the models are 5 times faster
and 10 times smaller.
</P>

<A NAME="czech-morfflex-pdt_acknowledgements"></A>
<H3>4.1.1. Acknowledgements</H3>

<P>
This work has been using language resources developed and/or stored and/or
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <I>LM2010013</I>).
</P>
<P>
The Czech morphological system was devised by Jan Hajič.
</P>
<P>
The MorfFlex CZ dictionary was created by Jan Hajič and Jaroslava Hlaváčová.
</P>
<P>
The morphological guesser research was supported by the projects
<I>1ET101120503</I> and <I>1ET101120413</I> of Academy of Sciences of the Czech
Republic and <I>100008/2008</I> of Charles University Grant Agency. The research
was performed by Jan Hajič, Jaroslava Hlaváčová and David Kolovratník.
</P>
<P>
The tagger algorithm and feature set research was supported by the projects
<I>MSM0021620838</I> and <I>LC536</I> of Ministry of Education, Youth and Sports of the Czech Republic,
<I>GA405/09/0278</I> of the Grant Agency of the Czech Republic and <I>1ET101120503</I> of
Academy of Sciences of the Czech Republic. The research was performed by
Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab and Miroslav Spousta.
</P>
<P>
The tagger is trained on morphological layer of Prague Dependency Treebank PDT
2.5, which was supported by the projects <I>LM2010013</I>, <I>LC536</I>,
<I>LN00A063</I> and <I>MSM0021620838</I> of Ministry of Education, Youth and Sports
of the Czech Republic, and developed by Martin Buben, Jan Hajič, Jiří Hana,
Hana Hanová, Barbora Hladká, Emil Jeřábek, Lenka Kebortová, Kristýna Kupková,
Pavel Květoň, Jiří Mírovský, Andrea Pfimpfrová, Jan Štěpánek and Daniel Zeman.
</P>

<H4>4.1.1.1. Publications</H4>

<UL>
<LI>(Hajič 2004) Jan Hajič. <I><A HREF="http://books.google.cz/books?id=sB63AAAACAAJ">Disambiguation of Rich Inflection: Computational Morphology of Czech.</A></I> Karolinum Press (2004).
<P></P>
<LI>Hlaváčová Jaroslava, Kolovratník David. <I>Morfologie češtiny znovu a lépe.</I> In Informačné Technológie - Aplikácie a Teória. Zborník príspevkov, ITAT 2008.  Seňa, Slovakia: PONT s.r.o., 2008, pp. 43-47.
<P></P>
<LI>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <I><A HREF="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</A></I> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
</UL>

<A NAME="czech_morphological_system"></A>
<H3>4.1.2. Czech Morphological System</H3>

<P>
In the Czech language, MorphoDiTa uses Czech morphological system by
Jan Hajič (<A HREF="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</A>).
In this system, which we call <I>PDT tag set</I>, the tags are positional with 15
positions corresponding to part of speech, detailed part of speech, gender,
number, case, etc. (e.g. <CODE>NNFS1-----A----</CODE>).  Different meanings of same
lemmas are distinguished and additional comments can be provided for every
lemma meaning. The lemma itself without the comments and meaning specification
is called a <I>raw lemma</I>. The following examples illustrate this:
</P>

<UL>
<LI><CODE>Japonsko_;G</CODE> (raw lemma: <CODE>Japonsko</CODE>)
<LI><CODE>se_^(zvr._zájmeno/částice)</CODE> (raw lemma: <CODE>se</CODE>)
<LI><CODE>tvořit_:T</CODE> (raw lemma: <CODE>tvořit</CODE>)
</UL>

<P>
For a more detailed reference about the Czech morphology, please see
<A HREF="http://ufal.mff.cuni.cz/pdt2.0/doc/manuals/en/m-layer/html/ch02.html">Lemma and Tag Structure in PDT 2.0</A>.
</P>

<A NAME="toc19"></A>
<H3>4.1.3. Main Czech Model</H3>

<P>
The main Czech model contains the following files:
</P>

<DL>
<DT><CODE>czech-morfflex-&lt;version&gt;.dict</CODE></DT><DD>
  Morphological dictionary based on the Jan Hajič's (<A HREF="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</A>)
  system with PDT tag set created from
  <A HREF="http://hdl.handle.net/11858/00-097C-0000-0015-A780-9">MorfFlex CZ</A> morphological dictionary.
<P></P>
<DT><CODE>czech-morfflex-pdt-&lt;version&gt;.tagger-best_accuracy</CODE></DT><DD>
  Best and slowest tagger (Viterbi of order 3) trained on the training portion
  of <A HREF="http://ufal.mff.cuni.cz/pdt2.5/">PDT 2.5</A> using the <CODE>neopren</CODE> feature
  set. Contains the <CODE>czech-morfflex-&lt;version&gt;.dict</CODE> morphological dictionary.
<P></P>
  The latest version <CODE>czech-morfflex-pdt-131112.tagger-best_accuracy</CODE> reaches 95.67% tag
  accuracy, 97.78% lemma accuracy and 94.97% overall accuracy on
  <A HREF="http://ufal.mff.cuni.cz/pdt2.5/">PDT 2.5</A> etest data (whose morphological tags and lemmas
  were remapped using the <CODE>czech-morfflex-131112.dict</CODE> dictionary). Model speed: ~10k words/s,
  model size: 18MB. For comparison, model trained by
  <A HREF="http://sourceforge.net/projects/featurama/">Featurama</A> (state-of-the-art
  Czech tagger implementation) reaches 95.66%, 97.70%, 94.90% of tag, lemma and
  overall accuracy, respectively, with speed ~2k words/s and size 210MB.
<P></P>
<DT><CODE>czech-morfflex-pdt-&lt;version&gt;.tagger-fast</CODE></DT><DD>
  Faster tagger with slightly worse results (Viterbi of order 2) trained on the
  training portion of <A HREF="http://ufal.mff.cuni.cz/pdt2.5/">PDT 2.5</A> using the <CODE>neopren</CODE>
  feature set. Contains the <CODE>czech-morfflex-&lt;version&gt;.dict</CODE> morphological dictionary.
<P></P>
  The latest version <CODE>czech-morfflex-pdt-131112.tagger-fast</CODE> reaches 94.70% tag accuracy,
  97.64% lemma accuracy and 93.94% overall accuracy on
  <A HREF="http://ufal.mff.cuni.cz/pdt2.5">PDT 2.5</A> etest data (whose morphological tags and lemmas
  were remapped using the <CODE>czech-morfflex-131112.dict</CODE> dictionary). Model speed: ~60k words/s,
  model size: 11MB.
</DL>

<A NAME="toc20"></A>
<H3>4.1.4. Part of Speech Only Variant</H3>

<P>
The PDT tag set used by the main Czech model is very fine-grained. In many
situations, only the part of speech tags would be sufficient. Therefore, we
provide a variant of the model, denoted as <CODE>pos_only</CODE>, where only the first
two characters of the fifteen-letter tags are used, representing the part of
speech and detailed part of speech, respectively. There are 67 such two-letter tags.
</P>

<DL>
<DT><CODE>czech-morfflex-&lt;version&gt;-pos_only.dict</CODE></DT><DD>
  Morphological dictionary based on the Jan Hajič's (<A HREF="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</A>)
  system created from
  <A HREF="http://hdl.handle.net/11858/00-097C-0000-0015-A780-9">MorfFlex CZ</A> morphological dictionary.
  Only first two tag characters of PDT tag set are used.
<P></P>
<DT><CODE>czech-morfflex-pdt-&lt;version&gt;-pos_only.tagger</CODE></DT><DD>
  Very fast tagger trained on the training portion of
  <A HREF="http://ufal.mff.cuni.cz/pdt2.5/">PDT 2.5</A> using the <CODE>neopren</CODE> feature
  set. Containins the <CODE>czech-morfflex-&lt;version&gt;-pos_only.dict</CODE> morphological dictionary.
<P></P>
  The latest version <CODE>czech-morfflex-pdt-131112-pos_only.tagger</CODE> reaches 99.20% tag
  accuracy, 97.64% lemma accuracy and 97.60% overall accuracy on
  <A HREF="http://ufal.mff.cuni.cz/pdt2.5">PDT 2.5</A> etest data (which morphological tags and lemmas
  were remapped using the <CODE>czech-morfflex-131112-pos_only.dict</CODE> dictionary).
  Model speed: ~200k words/s, model size: 4MB.
</DL>

<A NAME="toc21"></A>
<H3>4.1.5. Raw Lemmas Variant</H3>

<P>
The Czech morphological system distinguish different meanings of same lemmas by
numbering the lemmas with multiple meanings and supplying additional comments
for every lemma meaning, as described and demonstrated in
<A HREF="#czech_morphological_system">Czech Morphological System</A>. Sometimes this may be
undesirable, for example when comparing to systems which do not use the
<A HREF="http://hdl.handle.net/11858/00-097C-0000-0015-A780-9">MorfFlex CZ</A> morphological dictionary.
</P>
<P>
Therefore, all already mentioned Czech models have a variant which does not
disambiguate lemma meanings and provides no additional comments. (In terms of
MorphoDiTa API, the lemmas are <I>raw lemmas</I> with empty <I>lemma ids</I> and
<I>lemma comments</I>.) These model variants are denoted by <CODE>raw_lemmas</CODE>.
</P>

<A NAME="english-morphium-wsj"></A>
<H2>4.2. English MorphoDiTa Models</H2>

<P>
English models are created using the following data:
</P>

<UL>
<LI><I>SCOWL (Spell Checker Oriented Word Lists)</I>: This word list is used
  in morphological generation to create all possible word forms of a given
  word.
<P></P>
  Copyright: <I>Copyright 2000-2011 by Kevin Atkinson. Permission to use, copy, modify, distribute and sell these word lists, the associated scripts, the output created from the scripts, and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appears in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Kevin Atkinson makes no representations about the suitability of this array for any purpose. It is provided "as is" without express or implied warranty.</I>
<P></P>
<LI><I>Wall Street Journal</I>, part of the Penn Treebank 3: Morphologically
  annotated texts which are commonly used to train English POS tagger.
<P></P>
  Licensing: Available as LDC99T42 in LDC catalog under LDC User Agreement.
</UL>

<P>
The resulting models are distributed under the
<A HREF="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA</A> licence.
English models work in MorphoDiTa version 1.1 or later.
</P>
<P>
English models are versioned according to the release date, the version
format is <CODE>YYMMDD</CODE>, where <CODE>YY</CODE>, <CODE>MM</CODE> and <CODE>DD</CODE> are two-digit
representation of year, month and day, respectively. The latest version is
140407.
</P>

<A NAME="english-morphium-wsj_acknowledgements"></A>
<H3>4.2.1. Acknowledgements</H3>

<P>
This work has been using language resources developed and/or stored and/or
distributed by the LINDAT/CLARIN project of the Ministry of Education of the
Czech Republic (project <I>LM2010013</I>).
</P>
<P>
The morphological POS analyzer development was supported by grant of the Ministry
of Education, Youth and Sports of the Czech Republic No. <I>LC536</I> "Center for
Computational Linguistics". The morphological POS analyzer research was
performed by Johanka Spoustová (Spoustová 2008; the <CODE>Treex::Tool::EnglishMorpho::Analysis</CODE>
Perl module). The lemmatizer was implemented by Martin Popel (Popel 2009; the
<CODE>Treex::Tool::EnglishMorpho::Lemmatizer</CODE> Perl module). The lemmatizer is
based on <CODE>morpha</CODE>, which was released under LGPL licence as a part of
<A HREF="http://ilexir.co.uk/applications/rasp">RASP system</A>.
</P>
<P>
The tagger algorithm and feature set research was supported by the projects
<I>MSM0021620838</I> and <I>LC536</I> of Ministry of Education, Youth and Sports of the Czech Republic,
<I>GA405/09/0278</I> of the Grant Agency of the Czech Republic and <I>1ET101120503</I> of
Academy of Sciences of the Czech Republic. The research was performed by
Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab and Miroslav Spousta.
</P>

<H4>4.2.1.1. Publications</H4>

<UL>
<LI>(Popel 2009) Martin Popel. <I><A HREF="http://ufal.mff.cuni.cz/~popel/papers/master_thesis.pdf">Ways to Improve the Quality of English-Czech Machine Translation.</A></I> Master Thesis at Institute of Formal and Applied Linguistics, Faculty of Mathematics and Physics, Charles University in Prague (2009).
<P></P>
<LI>(Spoustová 2008) Drahomíra "johanka" Spoustová. <I><A HREF="http://ufal.mff.cuni.cz/morphium/">Morphium &ndash; morphological analyser for Penn treebank POS tagset.</A></I> Perl Software developed at Institute of Formal and Applied Linguistics, Faculty of Mathematics and Physics, Charles University in Prague (2008).
<P></P>
<LI>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <I><A HREF="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</A></I> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
</UL>

<A NAME="toc24"></A>
<H3>4.2.2. English Morphological System</H3>

<P>
The English morphology uses standard Penn Treebank POS tags. Nevertheless,
the lemma structure is unique:
</P>

<UL>
<LI>The lemmatizer recognizes negative prefixes and removes it from the lemma.
  In terms of MorphoDiTa API, <I>raw lemma</I> is the lemma without negative prefix.
<LI>The negative prefix is also stored to allow morphological generation of word
  form with the same negative prefix. In terms of MorphoDiTa API, <I>lemma id</I>
  is the raw lemma plus the negative prefix.
</UL>

<P>
The negative prefix is separated from the (always nonempty) lemma using a <CODE>^</CODE>
character (<CODE>able^un</CODE>). During morphological generation, the negative prefix is honored.
Furthermore, when the lemma ends with <CODE>^</CODE> (i.e., negative prefix is empty, as
in <CODE>able^</CODE>), forms with negative prefixes are generated. It is also possible
to generate all forms without any negative prefix by appending <CODE>+</CODE> after the lemma
(for example <CODE>able+</CODE>).
</P>

<A NAME="toc25"></A>
<H3>4.2.3. English Model</H3>

<P>
The English model contains the following files:
</P>

<DL>
<DT><CODE>english-morphium-&lt;version&gt;.dict</CODE></DT><DD>
  Morphological dictionary. The SCOWL word list has been automatically analyzed
  and lemmatized and uses as the dictionary. The guesser performing the analyzation
  and lemmatization is available.
<P></P>
<DT><CODE>english-morphium-wsj-&lt;version&gt;.tagger</CODE></DT><DD>
  Tagger trained on the training portion of Wall Street Journal (Sections 0-18)
  and tuned on the development portion (Sections 19-21). Contains the
  <CODE>english-morphium-&lt;version&gt;.dict</CODE> morphological dictionary.
<P></P>
  The latest version <CODE>english-morphium-wsj-140407.tagger</CODE> reaches 97.27% tag
  accuracy on Wall Street Journal test portion (Section 22-24). Model speed: ~60k words/s,
  model size: 6MB.
</DL>

<A NAME="toc26"></A>
<H3>4.2.4. No Negations Variant</H3>

<P>
Stripping of negative prefixes (or handling the lemmas with negative prefixes
stripped) may not be desirable. Therefore, a variant of the English model
denoted by <CODE>no_negation</CODE> is provided, which does not strip negative prefixes
from lemmas.
</P>

<DL>
<DT><CODE>english-morphium-&lt;version&gt;-no_negation.dict</CODE></DT><DD>
  Morphological dictionary which does not strip negative lemma prefixes. The
  SCOWL word list has been automatically analyzed and lemmatized and uses as
  the dictionary. The guesser performing the analyzation and lemmatization is
  available.
<P></P>
<DT><CODE>english-morphium-wsj-&lt;version&gt;-no_negation.tagger</CODE></DT><DD>
  Tagger which does not strip negative lemma prefixes, trained on the training
  portion of Wall Street Journal (Sections 0-18) and tuned on the development
  portion (Sections 19-21). Contains the
  <CODE>english-morphium-&lt;version&gt;-no_negation.dict</CODE> morphological dictionary.
<P></P>
  The latest version <CODE>english-morphium-wsj-140407-no_negation.tagger</CODE> reaches 97.25%
  tag accuracy on Wall Street Journal test portion (Section 22-24). Model
  speed: ~60k words/s, model size: 6MB.
</DL>

<A NAME="toc27"></A>
<H3>4.2.5. English Model Changes</H3>

<DL>
<DT><CODE>english-morphium-140407</CODE> and <CODE>english-morphium-wsj-140407</CODE> (require MorphoDiTa 1.1 or later)</DT><DD>
  Recognize also "non-" as a negative prefix. Formerly, only "non" was recognized.
<P></P>
<DT><CODE>english-morphium-140304</CODE> and <CODE>english-morphium-wsj-140304</CODE> (require MorphoDiTa 1.0 or later)</DT><DD>
  Initial release.
</DL>

<A NAME="run_tagger"></A>
<H2>4.3. Running the Tagger</H2>

<P>
Probably the most common usage of MorphoDita is running a tagger to tag your data using
</P>

<PRE>
run_tagger tagger_model
</PRE>

<P>
The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically.
</P>
<P>
Any number of files can be specified after the <CODE>tagger_model</CODE>. If an argument
<CODE>input_file:output_file</CODE> is used, the given <CODE>input_file</CODE> is processed and
the result is saved to <CODE>output_file</CODE>. If only <CODE>input_file</CODE> is used, the
result is saved to standard output. If no argument is given, input is read
from standard input and written to standard output.
</P>
<P>
The full command syntax of <CODE>run_tagger</CODE> is
</P>

<PRE>
run_tagger [options] tagger_file [file[:output_file]]...
Options: --input=untokenized|vertical
         --convert_tagset=pdt_to_conll2009
         --output=vertical|xml
</PRE>

<A NAME="toc29"></A>
<H3>4.3.1. Input Formats</H3>

<P>
The input format is specified using the <CODE>--input</CODE> option. Currently supported
input formats are:
</P>

<UL>
<LI><CODE>untokenized</CODE> (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
<LI><CODE>vertical</CODE>: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.
</UL>

<A NAME="toc30"></A>
<H3>4.3.2. Tag Set Conversion</H3>

<P>
Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
</P>

<UL>
<LI><CODE>pdt_to_conll2009</CODE>: convert Czech PDT tag set to CoNLL 2009 tag set.
</UL>

<A NAME="toc31"></A>
<H3>4.3.3. Output Formats</H3>

<P>
The output format is specified using the <CODE>--output</CODE> option. Currently
supported output formats are:
</P>

<UL>
<LI><CODE>xml</CODE> (default): Simple XML format without a root element, using
  <CODE>&lt;sentence&gt;</CODE> element to mark sentences and
  <CODE>&lt;token lemma="..." tag="..."&gt;...&lt;/token&gt;</CODE> element to encode token
  and its assigned lemma and tag.
<P></P>
  Example output for input <CODE>Děti pojedou k babičce. Už se těší.</CODE> (line breaks added):

<PRE>
&lt;sentence&gt;&lt;token lemma='dítě' tag='NNFP1-----A----'&gt;Děti&lt;/token&gt;
&lt;token lemma='jet-1_^(pohybovat_se,_ne_však_chůzí)' tag='VB-P---3F-AA---'&gt;pojedou&lt;/token&gt;
&lt;token lemma='k-1' tag='RR--3----------'&gt;k&lt;/token&gt;
&lt;token lemma='babička' tag='NNFS3-----A----'&gt;babičce&lt;/token&gt;
&lt;token lemma='.' tag='Z:-------------'&gt;.&lt;/token&gt;&lt;/sentence&gt;
&lt;sentence&gt;&lt;token lemma='už-1' tag='Db-------------'&gt;Už&lt;/token&gt;
&lt;token lemma='se_^(zvr._zájmeno/částice)' tag='P7-X4----------'&gt;se&lt;/token&gt;
&lt;token lemma='těšit_:T' tag='VB-S---3P-AA---'&gt;těší&lt;/token&gt;
&lt;token lemma='.' tag='Z:-------------'&gt;.&lt;/token&gt;&lt;/sentence&gt;
</PRE>

<P></P>
<LI><CODE>vertical</CODE>: Every output line is a tag separated triple form-lemma-tag, with empty
  line denoting end of sentence.
<P></P>
  Example output for input <CODE>Děti pojedou k babičce. Už se těší.</CODE>:

<PRE>
Děti	dítě	NNFP1-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------
babičce	babička	NNFS3-----A----
.	.	Z:-------------

Už	už-1	Db-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------
těší	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
</PRE>

</UL>

<A NAME="toc32"></A>
<H2>4.4. Running the Morphology</H2>

<P>
There are multiple commands performing morphological tasks.
The <A HREF="#run_morpho_analyze"><CODE>run_morpho_analyze</CODE></A> executable performs morphological analysis and
the <A HREF="#run_morpho_generate"><CODE>run_morpho_generate</CODE></A> executable performs morphological generation.
The output of these commands is suitable for automatic processing.
</P>
<P>
The <A HREF="#run_morpho_cli"><CODE>run_morpho_cli</CODE></A> executable performs both morphological analysis and generation,
but is designed to be used interactively and produces more human-readable output.
</P>

<A NAME="run_morpho_analyze"></A>
<H3>4.4.1. Morphological Analysis</H3>

<P>
The morphological analysis can be performed by running
</P>

<PRE>
run_morpho_analyze morphology_model use_guesser
</PRE>

<P>
The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically. The input files are specified same as with the
<A HREF="#run_tagger"><CODE>run_tagger</CODE></A> command.
</P>
<P>
Some morphological models contain both a manually created dictionary and
a guesser. Therefore, a numeric <CODE>use_guesser</CODE> argument is required.
If non-zero, the guesser is used, otherwise not.
</P>
<P>
Because tagger models contain an embedded morphological model, a tagger model
can be used instead of morphological one if <CODE>--from_tagger</CODE> option is
specified.
</P>
<P>
The full command syntax of <CODE>run_morpho_analyze</CODE> is
</P>

<PRE>
run_morpho_analyze [options] morphology_model use_guesser [file[:output_file]]...
Options: --input=untokenized|vertical
         --convert_tagset=pdt_to_conll2009
         --output=vertical|xml
         --from_tagger
</PRE>

<H4>4.4.1.1. Input Formats</H4>

<P>
The input format is specified using the <CODE>--input</CODE> option. Currently supported
input formats are:
</P>

<UL>
<LI><CODE>untokenized</CODE> (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
<LI><CODE>vertical</CODE>: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.
</UL>

<P>
Note that the input data is also segmented, even if it is not strictly
necessary. Therefore, the input is processed by whole paragraphs (ending
by an empty line).
</P>

<H4>4.4.1.2. Tag Set Conversion</H4>

<P>
Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
</P>

<UL>
<LI><CODE>pdt_to_conll2009</CODE>: convert Czech PDT tag set to CoNLL 2009 tag set.
</UL>

<H4>4.4.1.3. Output Formats</H4>

<P>
The output format is specified using the <CODE>--output</CODE> option. Currently
supported output formats are:
</P>

<UL>
<LI><CODE>xml</CODE> (default): Simple XML format without a root element, using
  using <CODE>&lt;token&gt;&lt;analysis lemma="..." tag="..."/&gt;&lt;analysis...&gt;...&lt;/token&gt;</CODE>
  element to encode morphological analysis.
<P></P>
  Example output for input <CODE>Děti pojedou k babičce. Už se těší.</CODE> (line breaks added):

<PRE>
&lt;sentence&gt;&lt;token&gt;&lt;analysis lemma="dítě" tag="NNFP1-----A----"/&gt;&lt;analysis lemma="dítě" tag="NNFP4-----A----"/&gt;&lt;analysis lemma="dítě" tag="NNFP5-----A----"/&gt;Děti&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="jet-1_^(pohybovat_se,_ne_však_chůzí)" tag="VB-P---3F-AA---"/&gt;pojedou&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="k-1" tag="RR--3----------"/&gt;&lt;analysis lemma="k-3_^(označení_pomocí_písmene)" tag="NNNXX-----A----"/&gt;&lt;analysis lemma="k-4`kůň_:B_^(jednotka_výkonu)" tag="NNMXX-----A---8"/&gt;&lt;analysis lemma="k-8_:B_^(ost._zkratka)" tag="XX------------8"/&gt;&lt;analysis lemma="komanditní_:B_^(jen_komanditní_společnost)" tag="AAXXX----1A---8"/&gt;&lt;analysis lemma="koncernový_:B" tag="AAXXX----1A---8"/&gt;&lt;analysis lemma="kuo-1_:B_,t_^(stará_jednotka_výkonu)" tag="NNNXX-----A---8"/&gt;k&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="babička" tag="NNFS3-----A----"/&gt;&lt;analysis lemma="babička" tag="NNFS6-----A----"/&gt;babičce&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="." tag="Z:-------------"/&gt;.&lt;/token&gt;&lt;/sentence&gt;
&lt;sentence&gt;&lt;token&gt;&lt;analysis lemma="už-1" tag="Db-------------"/&gt;&lt;analysis lemma="už-2" tag="TT-------------"/&gt;Už&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="se_^(zvr._zájmeno/částice)" tag="P7-X4----------"/&gt;&lt;analysis lemma="s-1" tag="RV--2----------"/&gt;&lt;analysis lemma="s-1" tag="RV--7----------"/&gt;se&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="těšit_:T" tag="VB-P---3P-AA---"/&gt;&lt;analysis lemma="těšit_:T" tag="VB-S---3P-AA---"/&gt;těší&lt;/token&gt;
&lt;token&gt;&lt;analysis lemma="." tag="Z:-------------"/&gt;.&lt;/token&gt;&lt;/sentence&gt;
</PRE>

<P></P>
<LI><CODE>vertical</CODE>: Every output line contains a word and a tab separated lemma-tag
  pairs assigned to the input word, with empty line denoting end of sentence.
<P></P>
  Example output for input <CODE>Děti pojedou k babičce. Už se těší.</CODE>:

<PRE>
Děti	dítě	NNFP1-----A----	dítě	NNFP4-----A----	dítě	NNFP5-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------	k-3_^(označení_pomocí_písmene)	NNNXX-----A----	k-4`kůň_:B_^(jednotka_výkonu)	NNMXX-----A---8	k-8_:B_^(ost._zkratka)	XX------------8	komanditní_:B_^(jen_komanditní_společnost)	AAXXX----1A---8	koncernový_:B	AAXXX----1A---8	kuo-1_:B_,t_^(stará_jednotka_výkonu)	NNNXX-----A---8
babičce	babička	NNFS3-----A----	babička	NNFS6-----A----
.	.	Z:-------------

Už	už-1	Db-------------	už-2	TT-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------	s-1	RV--2----------	s-1	RV--7----------
těší	těšit_:T	VB-P---3P-AA---	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
</PRE>

</UL>

<A NAME="run_morpho_generate"></A>
<H3>4.4.2. Morphological Generation</H3>

<P>
The morphological generation can be performed by running
</P>

<PRE>
run_morpho_generate morphology_model use_guesser
</PRE>

<P>
The input is assumed to be in UTF-8 encoding. The input files are specified
same as with the <A HREF="#run_tagger"><CODE>run_tagger</CODE></A> command.
</P>
<P>
Input for morphological generation has to be in vertical format, each line
containing a lemma, which can be optionally followed by a tab and a
<A HREF="#tag_wildcard">tag wildcard</A>. The output has the same number of lines as input,
line <I>l</I> contains tab separated form-lemma-tag triplets which can be generated
from the lemma on he input line <I>l</I>. If a tag wildcard was provided, only
triplets with matching tags are returned.
</P>
<P>
Some morphological models contain both a manually created dictionary and
a guesser. Therefore, a numeric <CODE>use_guesser</CODE> argument is required.
If non-zero, the guesser is used, otherwise not.
</P>
<P>
Because tagger models contain an embedded morphological model, a tagger model
can be used instead of morphological one if <CODE>--from_tagger</CODE> option is
specified.
</P>
<P>
The full command syntax of <CODE>run_morpho_generate</CODE> is
</P>

<PRE>
run_morpho_generate [options] morphology_model use_guesser [input_file[:output_file]]...
Options: --convert_tagset=pdt_to_conll2009
         --from_tagger
</PRE>

<P>
Example input data:
</P>

<PRE>
dítě
jet	?[fN]??[-1]
k-1
babička	NNFS3-----A----
</PRE>

<P>
Example output:
</P>

<PRE>
dítě	dítě	NNNS1-----A----	dítě	dítě	NNNS4-----A----	dítě	dítě	NNNS5-----A----	dítěte	dítě	NNNS2-----A----	dítěti	dítě	NNNS3-----A----	dítěti	dítě	NNNS6-----A----	dítětem	dítě	NNNS7-----A----	děti	dítě	NNFP1-----A----	děti	dítě	NNFP4-----A----	děti	dítě	NNFP5-----A----	dětma	dítě	NNFP7-----A---6	dětmi	dítě	NNFP7-----A----	dětem	dítě	NNFP3-----A----	dětí	dítě	NNFP2-----A----	dětech	dítě	NNFP6-----A----	dětima	dítě_,h	NNFP7-----A---6
ject	jet	Vf--------A---6	jet	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------A----	jeti	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------A---2	nejet	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------N----	nejeti	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------N---2	jet	jet-2_,h_^(letadlo_s_tryskovým_pohonem)NNIS1-----A----	jety	jet-2_,h_^(letadlo_s_tryskovým_pohonem)	NNIP1-----A----
k	k-1	RR--3----------	ke	k-1	RV--3----------	ku	k-1	RV--3---------1
babičce babička NNFS3-----A----
</PRE>

<H4>4.4.2.1. Tag Set Conversion</H4>

<P>
Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
</P>

<UL>
<LI><CODE>pdt_to_conll2009</CODE>: convert Czech PDT tag set to CoNLL 2009 tag set.
</UL>

<P>
Note that the tag set conversion is applied only to the output, not to the
input lemmas and wildcards.
</P>

<A NAME="tag_wildcard"></A>
<H4>4.4.2.2. Tag Wildcards</H4>

<P>
When only forms with a specific tag should be generated for a given lemma, tag
wildcard can be specified. The tag wildcard is a simple wildcard allowing to filter
the results of morphological generation.
</P>
<P>
Most characters of a tag wildcard match corresponding characters of a tag, with the following exceptions:
</P>

 <UL>
 <LI><CODE>?</CODE> matches any character of a tag.
 <LI><CODE>[chars]</CODE> matches any of the characters listed. The dash <CODE>-</CODE> has no special meaning and if <CODE>]</CODE>
   is the first character in <CODE>chars</CODE>, it is considered as one of the characters and does not end the group.
 <LI><CODE>[^chars]</CODE> matches any of the characters <I>not</I> listed.
 </UL>

<A NAME="run_morpho_cli"></A>
<H3>4.4.3. Interactive Morphological Analysis and Generation</H3>

<P>
Morphological analysis and generation which is interactive and more human readable
can be run using:
</P>

<PRE>
run_morpho_cli morphology_model
</PRE>

<P>
The input is read from standard input, command on each line. If there is no tab
on a line, analysis is performed on the given word. If there is a tab on
a line, generation is performed on the first word, using the second word as
a <A HREF="#tag_wildcard">tag wildcard</A>.  If the second word is empty (i.e., the input
is for example ``on	``), all forms are generated.
</P>
<P>
Because tagger models contain an embedded morphological model, a tagger model
can be used instead of morphological one if <CODE>--from_tagger</CODE> option is
specified.
</P>
<P>
The full command syntax of <CODE>run_morpho_cli</CODE> is
</P>

<PRE>
run_morpho_cli [options] morphology_model
Options: --from_tagger
</PRE>

<A NAME="run_tokenizer"></A>
<H2>4.5. Running the Tokenizer</H2>

<P>
Using the <CODE>run_tokenizer</CODE> executable it is possible to perform only
tokenization and segmentation.
</P>
<P>
The input is a UTF-8 encoded plain text and the input files are specified same
as with the <A HREF="#run_tagger"><CODE>run_tagger</CODE></A> command.
</P>
<P>
The tokenizer can be specified either by using a morphology model
(<CODE>--morphology</CODE> option), tagger model (<CODE>--tagger</CODE> option) or by using
a tokenizer identifier (<CODE>--tokenizer</CODE> option). Currently supported
tokenizer identifiers are:
</P>

<UL>
<LI><CODE>czech</CODE>
<LI><CODE>english</CODE>
<LI><CODE>generic</CODE>
</UL>

<P>
The full command syntax of <CODE>run_tokenizer</CODE> is
</P>

<PRE>
run_tokenizer [options] [file[:output_file]]...
Options: --tokenizer=czech|english|generic
         --morphology=morphology_model_file
         --tagger=tagger_model_file
         --output=vertical|xml
</PRE>

<A NAME="toc37"></A>
<H3>4.5.1. Output Formats</H3>

<P>
The output format is specified using the <CODE>--output</CODE> option. Currently
supported output formats are:
</P>

<UL>
<LI><CODE>xml</CODE> (default): Simple XML format without a root element, using
  <CODE>&lt;sentence&gt;</CODE> element to mark sentences and <CODE>&lt;token&gt;</CODE> element to mark
  tokens.
<P></P>
  Example output for input <CODE>Děti pojedou k babičce. Už se těší.</CODE> (line breaks added):

<PRE>
&lt;sentence&gt;&lt;token&gt;Děti&lt;/token&gt; &lt;token&gt;pojedou&lt;/token&gt; &lt;token&gt;k&lt;/token&gt;
&lt;token&gt;babičce&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt; &lt;sentence&gt;&lt;token&gt;Už&lt;/token&gt;
&lt;token&gt;se&lt;/token&gt; &lt;token&gt;těší&lt;/token&gt;&lt;token&gt;.&lt;/token&gt;&lt;/sentence&gt;
</PRE>

<P></P>
<LI><CODE>vertical</CODE>: Each token is on a separate line, every sentence is ended by
  a blank line.
<P></P>
  Example output for input <CODE>Děti pojedou k babičce. Už se těší.</CODE>:

<PRE>
Děti
pojedou
k
babičce
.

Už
se
těší
.

</PRE>

</UL>

<A NAME="custom_models"></A>
<H2>4.6. Custom Morphological and Tagging Models</H2>

<P>
It is possible to create custom morphological and tagging models.
</P>

<A NAME="toc39"></A>
<H3>4.6.1. Custom Morphological Models</H3>

<P>
Custom morphological models can be created using <CODE>encode_dictionary</CODE> binary.
</P>
<P>
The <CODE>encode_dictionary</CODE> reads from standard input and prints MorphoDiTa
morphological model on standard output.  The input of <CODE>encode_dictionary</CODE> is
a textual representation of morphological dictionary. It should be UTF-8
encoded and every line should be a tab separated triplet
<CODE>lemma \t tag \t form</CODE>. All forms of one lemma must appear in a continuous region and no line
should appear more than once (<CODE>sort -u</CODE> can be used to achieve this).
</P>
<P>
Run <CODE>encode_dictionary</CODE> with the following options:
</P>

<PRE>
encode_dictionary generic max_suffix_len unknown_tag number_tag punctuation_tag symbol_tag
</PRE>

<UL>
<LI><CODE>generic</CODE>: This parameter defines tokenizer and other language specific
  behaviour. Other values than <CODE>generic</CODE> take different options and are not
  documented.
<P></P>
<LI><CODE>max_suffix_len</CODE>: Maximum length of suffixes in automatically inferred
  inflexion classes.  If unsure, use 8 (we use 8 for Czech and 4 for English).
  Smaller values produce larger and slightly faster models.
<P></P>
<LI><CODE>unknown_tag</CODE>: Assigned to a form during analysis if no matching tag can be
  found.
<P></P>
<LI><CODE>number_tag</CODE>: Assigned to a form during analysis if the form was not found
  in the dictionary and it looks like a number. Can be the same as
  <CODE>unknown_tag</CODE>.
<P></P>
<LI><CODE>punctuation_tag</CODE>: Assigned to a form during analysis if the form was not found
  in the dictionary and it consists of Unicode characters in the Punctuation
  category. Can be the same as <CODE>unknown_tag</CODE>.
<P></P>
<LI><CODE>symbol_tag</CODE>: Assigned to a form during analysis if the form was not found
  in the dictionary and it consists of Unicode characters in the Symbol
  category. Can be the same as <CODE>unknown_tag</CODE>.
</UL>

<P>
Example input data:
</P>

<PRE>
dog	NN	dog
dog	NNS	dogs
go	VB	go
go	VBP	go
go	VBZ	goes
go	VBG	going
go	VBD	went
</PRE>

<P>
Example command line:
</P>

<PRE>
encode_dictionary generic 8 UNK NUM PUNC SYM &lt;input_data &gt;output_model
</PRE>

<H4>4.6.1.1. Using External Morphology</H4>

<P>
Sometimes it is useful to train MorphoDiTa tagger using external morphological
analysis, without having a MorphoDiTa morphological dictionary.
</P>
<P>
That is possible using a so called <I>external morphology model</I>. External
morphology model can be created easily using
</P>

<PRE>
encode_dictionary external unknown_tag &gt;output_model
</PRE>

<P>
No standard input is read in this case. The <CODE>unknown_tag</CODE> parameter is used when
no tag is assigned to a word form during analysis. The resulting model is
printed on standard output.
</P>
<P>
The external morphology model does not contain any morphological dictionary.
Instead, it expects the user to perform morphological analysis and generation on
their own. Therefore, the input form to analysis is expected to be followed by
space separated lemma-tag pairs, which are returned by the analysis.
Similarly, the input lemma to generation is expected to be followed by space
separated form-tag pairs, which are again returned by the generation (possibly
filtered by a tag wildcard). (To extract the length of the form or lemma itself
even when followed by external analyses, API calls <CODE>raw_form_len</CODE> or
<CODE>raw_lemma_len</CODE> and <CODE>lemma_id_len</CODE> can be used.)
</P>
<P>
Note that the tokenizer returned by the external morphology model is the same
as the tokenizer of the generic model, and splits input on spaces. Therefore,
it can be used to tokenize input, the tokens then passed to the external
morphology, and the results can be after proper formatting used as input to
MorphoDiTa in vertical input format.
</P>
<P>
Example input form for analysis using external morphology model:
</P>

<PRE>
wishes wish NNS wish VBZ
</PRE>

<P>
Example input lemma for generation using external morphology model:
</P>

<PRE>
go go VB go VBP goes VBZ going VBG went VBG
</PRE>

<A NAME="toc40"></A>
<H3>4.6.2. Custom Tagging Models</H3>

<P>
Custom tagging models can be trained using <CODE>train_tagger</CODE> binary, which has
the following options:
</P>

<PRE>
train_tagger generic_234 morphology use_guesser features iterations prune_features [heldout_data [early_stopping]] &lt;input_data &gt;tagger_model
</PRE>

<UL>
<LI><CODE>generic_234</CODE>: This parameter defines the tagger (elementary features and
  algorithm) and the order of Viterbi decoding. Use either <CODE>generic2</CODE>,
  <CODE>generic3</CODE> or <CODE>generic4</CODE>. If unsure, use <CODE>generic3</CODE> (best released
  Czech and English models use <CODE>generic3</CODE>). The <CODE>generic2</CODE> produces faster,
  but less accurate models, <CODE>generic4</CODE> produces larger and only marginally
  better models.
<P></P>
<LI><CODE>morphology</CODE>: File with the morphological dictionary to use.
<P></P>
<LI><CODE>use_guesser</CODE>: Use <CODE>0</CODE>/<CODE>1</CODE> to specify whether morphological guesser
  should be used. Unless you have a good reason not to, use <CODE>1</CODE>.
<P></P>
<LI><CODE>features</CODE>: File with feature sequences for the tagger. The file format and available
  elementary features are <A HREF="#tagger_feature_file_format">described in following section</A>.
<P></P>
<LI><CODE>iterations</CODE>: Number of training iterations. For English, values 5-10 are used,
  for Czech, values 10-15 are used. Can be affected by <CODE>early_stopping</CODE>.
<P></P>
<LI><CODE>prune_features</CODE>: Use <CODE>0</CODE>/<CODE>1</CODE> to disable/enable pruning of feature
  sequences not found in training data. Use <CODE>1</CODE> for smaller and marginally
  less accurate models, and <CODE>0</CODE> for larger and marginally better models.
  If unsure, use <CODE>1</CODE> (best released Czech and English models use <CODE>1</CODE>).
<P></P>
<LI><CODE>heldout_data</CODE>: Optional file with heldout data in the same format as input
  data.  If supplied, accuracy is measured on the heldout data after every
  training iteration.
<P></P>
<LI><CODE>early_stopping</CODE>: Optionally use <CODE>0</CODE>/<CODE>1</CODE> to disable/enable early
  stopping. If early stopping is enabled, the resulting model is not the one
  after the last training iteration, but the one with best heldout data
  accuracy.
</UL>

<P>
Example command line (use morphology from <CODE>morpho.dict</CODE>, features from <CODE>features.ft</CODE> and no heldout data):
</P>

<PRE>
train_tagger generic3 morpho.dict 1 features.ft 10 1 &lt;input.data &gt;tagger.model
</PRE>

<P>
Example command line (use morphology from <CODE>morpho.dict</CODE>, features from <CODE>features.ft</CODE> and use heldout data with early stopping):
</P>

<PRE>
train_tagger generic3 morpho.dict 1 features.ft 15 1 heldout.data 1 &lt;input.data &gt;tagger.model
</PRE>

<P>
See next sections for examples of input data and feature files.
</P>

<A NAME="tagger_input_format"></A>
<H4>4.6.2.1. Input Data Format</H4>

<P>
The input data (and the heldout data) represent a sequence of sentences.
Different sentences do not interact in any way. Words of one sentence are
stored on consecutive lines, each line containing tab separated triplet
<CODE>form \t lemma \t tag</CODE> in UTF-8 encoding. End of sentence is denoted
by an empty line.
</P>
<P>
Example:
</P>

<PRE>
Děti	dítě	NNFP1-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------
babičce	babička	NNFS3-----A----
.	.	Z:-------------

Už	už-1	Db-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------
těší	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
</PRE>

<A NAME="tagger_feature_file_format"></A>
<H4>4.6.2.2. Feature File Format</H4>

<P>
The features used in the tagger have major influence on tagging performance.
The feature file contains several <I>feature sequences</I>, each sequence
consisting of several <I>elementary features</I>. The elementary features are
computed by MorphoDiTa and different tagger models can have a different set of
elementary features. Here we describe elementary features of <CODE>generic</CODE>
tagger:
</P>

<UL>
<LI><CODE>Form</CODE>: word form
<LI><CODE>Prefix1</CODE> .. <CODE>Prefix9</CODE>: word form prefix of length 1..9 (measured in Unicode characters)
<LI><CODE>Suffix1</CODE> .. <CODE>Suffix9</CODE>: word form suffix of length 1..9 (measured in Unicode characters)
<LI><CODE>Num</CODE>: whether the word form contains at least one numbers (Unicode category Number)
<LI><CODE>Cap</CODE>: whether the word form contains at least one uppercase or titlecase letter
<LI><CODE>Dash</CODE>: whether the word form contains at least one dash (Unicode category 'Punctuation, Dash')
<LI><CODE>Tag</CODE>: word form PoS tag
<LI><CODE>Tag1</CODE> .. <CODE>Tag5</CODE>: letter 1..5 of word form PoS tag
<LI><CODE>Lemma</CODE>: word form lemma
<LI><CODE>FollowingVerbTag</CODE>: PoS tag of a nearest following verb, i.e., a nearest
  following word form with at least one of the PoS tags starting with <CODE>V</CODE>
<LI><CODE>FollowingVerbLemma</CODE>: lemma of a nearest following verb, i.e., a nearest
  following word form with at least one of the PoS tags starting with <CODE>V</CODE>
<LI><CODE>PreviousVerbTag</CODE>: PoS tag of a nearest previous verb, i.e., a nearest
  previous word whose PoS tag (assigned by the tagger) starts with <CODE>V</CODE>
<LI><CODE>PreviousVerbTag</CODE>: lemma of a nearest previous verb, i.e., a nearest
  previous word whose PoS tag (assigned by the tagger) starts with <CODE>V</CODE>
</UL>

<P>
The feature file defines <I>feature sequences</I> which can be applied to a word
form. A feature sequence consists of elementary features assigned to the given
form or its neighbours.
</P>
<P>
Every line in the feature file defines one feature sequence. A feature sequence
consists of comma joined space separated pairs of elementary feature and an
offset to which does the elementary feature apply (i.e., <CODE>Form 0</CODE> or
<CODE>Tag 0,Lemma -1</CODE>). The file format is strict and does not allow any
additional spaces or commas.
</P>
<P>
Note that offset of some of the elementary features is affected by the order or
Viterbi decoding used. Notably, if Viterbi decoding of order <I>N</I> is utilized,
<CODE>Tag</CODE> and <CODE>Lemma</CODE> can be used inside the decoded window, i.e., only with
offsets <I>-N+1</I> .. <I>0</I>.
</P>
<P>
For inspiration, we present feature files used for releases Czech
and English MorphoDiTa models. Both these feature files are slight
modifications of feature files described in the paper
Spoustová et al. 2009: Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <I><A HREF="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</A></I> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
</P>
<P>
Feature file for English:
</P>

<PRE>
Tag 0,Form 0
Tag 0,Prefix1 0
Tag 0,Prefix2 0
Tag 0,Prefix3 0
Tag 0,Prefix4 0
Tag 0,Prefix5 0
Tag 0,Prefix6 0
Tag 0,Prefix7 0
Tag 0,Prefix8 0
Tag 0,Prefix9 0
Tag 0,Suffix1 0
Tag 0,Suffix2 0
Tag 0,Suffix3 0
Tag 0,Suffix4 0
Tag 0,Suffix5 0
Tag 0,Suffix6 0
Tag 0,Suffix7 0
Tag 0,Suffix8 0
Tag 0,Suffix9 0
Tag 0,Num 0
Tag 0,Cap 0
Tag 0,Dash 0
Tag 0,Tag -1
Tag 0,Tag -1,Tag -2
Tag 0,Form -1
Tag 0,Form -2
Tag 0,Form -1,Form -2
Tag 0,Form 1
Tag 0,Form 1,Form 2
Tag 0,Tag1 -1
Tag 0,Lemma -1
Lemma 0,Tag -1
</PRE>

<P>
Feature file for Czech (note that some feature sequences predict only part of
PoS tags trying to overcome data sparseness; <CODE>Tag2</CODE> is extended PoS, <CODE>Tag3</CODE>
is gender, <CODE>Tag5</CODE> is case):
</P>

<PRE>
Tag 0
Tag 0,Tag -1
Tag 0,Tag -1,Tag -2
Tag 0,Tag -2
Tag 0,Form 0
Tag 0,Form 0,Form -1
Tag 0,Form -1
Tag 0,Form -2
Tag 0,PreviousVerbTag 0
Tag 0,PreviousVerbLemma 0
Tag 0,FollowingVerbTag 0
Tag 0,FollowingVerbLemma 0
Tag 0,Lemma -1
Lemma 0,Tag -1
Tag 0,Form 1
Tag2 0,Tag5 0
Tag2 0,Tag5 0,Tag2 -1,Tag5 -1
Tag2 0,Tag5 0,Tag2 -1,Tag5 -1,Tag2 -2,Tag5 -2
Tag5 0
Tag5 0,Tag -1
Tag5 0,Tag -1,Tag -2
Tag5 0,Tag -2
Tag5 0,Form 0
Tag5 0,Form 0,Form -1
Tag5 0,Form -1
Tag5 0,Form -2
Tag5 0,PreviousVerbTag 0
Tag5 0,PreviousVerbLemma 0
Tag5 0,FollowingVerbTag 0
Tag5 0,FollowingVerbLemma 0
Tag5 0,Lemma -1
Tag5 0,Form 1
Tag3 0
Tag3 0,Tag -1
Tag3 0,Tag -1,Tag -2
Tag3 0,Tag -2
Tag3 0,Form 0
Tag3 0,Form 0,Form -1
Tag3 0,Form -1
Tag3 0,Form -2
Tag3 0,PreviousVerbTag 0
Tag3 0,PreviousVerbLemma 0
Tag3 0,FollowingVerbTag 0
Tag3 0,FollowingVerbLemma 0
Tag3 0,Lemma -1
Tag3 0,Form 1
Tag 0,Prefix1 0
Tag 0,Prefix2 0
Tag 0,Prefix3 0
Tag 0,Prefix4 0
Tag 0,Suffix1 0
Tag 0,Suffix2 0
Tag 0,Suffix3 0
Tag 0,Suffix4 0
Tag 0,Num 0
Tag 0,Cap 0
Tag 0,Dash 0
Tag5 0,Suffix1 0
Tag5 0,Suffix2 0
Tag5 0,Suffix3 0
Tag5 0,Suffix4 0
</PRE>

<P>
Feature file for Czech, Part of Speech only variant:
</P>

<PRE>
Tag 0
Tag 0,Tag -1
Tag 0,Tag -1,Tag -2
Tag 0,Tag -2
Tag 0,Form 0
Tag 0,Form 0,Form -1
Tag 0,Form -1
Tag 0,Form -2
Tag 0,PreviousVerbTag 0
Tag 0,PreviousVerbLemma 0
Tag 0,FollowingVerbTag 0
Tag 0,FollowingVerbLemma 0
Tag 0,Lemma -1
Lemma 0,Tag -1
Tag 0,Form 1
Tag 0,Prefix1 0
Tag 0,Prefix2 0
Tag 0,Prefix3 0
Tag 0,Prefix4 0
Tag 0,Suffix1 0
Tag 0,Suffix2 0
Tag 0,Suffix3 0
Tag 0,Suffix4 0
Tag 0,Num 0
Tag 0,Cap 0
Tag 0,Dash 0
</PRE>

<H4>4.6.2.3. Measuring Tagger Accuracy</H4>

<P>
Measuring custom tagger accuracy can be performed by running:
</P>

<PRE>
tagger_accuracy tagger_model &lt;test_data
</PRE>

<P>
This binary reads input in the <A HREF="#tagger_input_format">same format as <CODE>train_tagger</CODE></A>,
i.e., tab separated form-lemma-tag triplets, and evaluates the accuracy
of the tagger model on the given testing data.
</P>

<A NAME="toc41"></A>
<H1>5. MorphoDiTa API Tutorial</H1>

<P>
The MorphoDiTa API is defined in header <CODE>morphodita.h</CODE> and resides in
<CODE>ufal::morphodita</CODE> namespace. The easiest way to use MorphoDita is therefore:
</P>

<PRE>
#include morphodita.h

using namespace ufal::morphodita;
</PRE>

<A NAME="toc42"></A>
<H2>5.1. Tagger API</H2>

<P>
The main access to MorphoDiTa tagger is through class <CODE>tagger</CODE>.  An example
of this class usage can be found in program file <CODE>run_tagger.cpp</CODE>. A typical
tagger usage may look like this:
</P>

<PRE>
#include tagger/tagger.h;

using namespace ufal::morphodita;

//...

// load model to memory and construct tagger
tagger* my_tagger = tagger::load("path_to_model");

if (!t) ...

// create sample input
vector&lt;string&gt; words;
words.push_back("malý");
words.push_back("pes");

vector&lt;string_piece&gt; forms;
for (auto&amp; word : words)
  forms.emplace_back(word)

// intialize output and tag
vector&lt;tagged_lemma&gt; tags;
my_tagger-&gt;tag(forms, tags);

// access the output
for (auto&amp; tag : tags)
  printf("%s\t%s\n", tag.lemma.c_str(), tag.tag.c_str());

delete my_tagger;
</PRE>

<P>
The tagger is constructed by an overloaded factory method with one argument.
The constructor either accepts a C file pointer (<CODE>FILE*</CODE>) pointing to a file
with the model or a C string (<CODE>const char*</CODE>) with a file name of the model.
The constructor loads the linguistic model to memory and returns the tagger
pointer ready for tagging, returning <CODE>NULL</CODE> if unsuccessful. If a file
pointer is used, it is not closed and is positioned right after the end of the
model.
</P>
<P>
The main tagging method is <CODE>tagger::tag</CODE>:
</P>

<PRE>
void tag(const std::vector&lt;string_piece&gt;&amp; forms, std::vector&lt;tagged_lemma&gt;&amp; tags) const;
</PRE>

<P>
The input is a <CODE>std::vector</CODE> of <CODE>string_piece</CODE> which is a structure
referencing a string using <CODE>const char* str</CODE> and <CODE>size_t len</CODE>.
</P>
<P>
The <CODE>tagger::tag</CODE> method returns the tagged output in it's second argument,
<CODE>std::vector&lt;tagged_lemma&gt;</CODE>. The calling procedure must provide a result vector
and the tagger assigns the output to this vector. Obviously, the indexes in the
output vector correspond to indexes in input vector.  <CODE>tagged_lemma</CODE> has two
public members: <CODE>std::string lemma</CODE> and <CODE>std:string tag</CODE>, corresponding to
predicted lemma and tag, respectively.
</P>

<A NAME="toc43"></A>
<H2>5.2. Morphological Dictionary API</H2>

<P>
The main access to MorphoDiTa morphological dictionary is through class
<CODE>morpho</CODE>. An example of this interface usage can be found in a program file
<CODE>run_morpho.cpp</CODE>.
</P>

<A NAME="toc44"></A>
<H3>5.2.1. Dictionary Construction</H3>

<P>
Similarly to the tagger, MorphoDiTa morphological dictionary is constructed by an
overloaded factory method which accepts either a C file pointer (<CODE>FILE*</CODE>)
or a C string <CODE>const char*</CODE> with the file name of the dictionary.
The factory method returns a pointer to morphological dictionary or <CODE>NULL</CODE> if
unsuccessful.
</P>

<PRE>
#include morpho/morpho.h

using namespace ufal::morphodita;

//...

// load dictionary to memory
morpho* my_morpho = morpho::load("path_to_dictionary");

//...

delete(my_morpho);
</PRE>

<P>
Another way of obtaining a pointer to morphology dictionary is through an instance
of <CODE>tagger</CODE> class &ndash; every tagger has a morphology dictionary, which is available
through the method
</P>

<PRE>
virtual const morpho* get_morpho() const = 0;
</PRE>

<P>
Please note that you should not delete this pointer as it is owned by the
<CODE>tagger</CODE> class instance.
</P>

<A NAME="toc45"></A>
<H3>5.2.2. Morphological Analysis</H3>

<P>
MorphoDiTa morphological dictionary offers two functionalities: It either
<I>analyzes</I> the given word, that means it outputs all possible lemma-tag pairs
candidates for the given form; or for a given lemma-tag pair, it <I>generates</I>
a form or a whole list of possible forms.
</P>
<P>
In the first case, one performs morphological analysis for a given word by
calling a method <CODE>morpho::analyze</CODE>:
</P>

<PRE>
int analyze(string_piece form, guesser_mode guesser, std::vector&lt;tagged_lemma&gt;&amp; lemmas) const;
</PRE>

<P>
An example (assuming that morphological dictionary is already constructed, see
previous example):
</P>

<PRE>
vector&lt;tagged_lemma&gt; lemmas;    // output

my_morpho-&gt;analyze("pes", morpho::GUESSER, vector&lt;tagged_lemma&gt;&amp; lemmas);

for (auto&amp; lemma: lemmas)
  printf ("%s %s\n, lemma.lemma.c_str(), lemma.tag.c_str())
</PRE>

<P>
The input is a form to analyze, then a Guesser mode (whether to use some kind
of guesser or strictly dictionary only, see question Guesser Mode in
<A HREF="#faq">Questions and Answers</A>) and output <CODE>std::vector&lt;tagged_lemma&gt;</CODE>.  The
caller must provide an output vector <CODE>std::vector&lt;tagged_lemma&gt;</CODE> and the
method <CODE>morpho::analyze</CODE> assigns the output to this vector.
</P>

<A NAME="toc46"></A>
<H3>5.2.3. Generation</H3>

<P>
MorphoDiTa performs morphological generation from a given lemma:
</P>

<PRE>
int generate(string_piece lemma, const char* tag_wildcard, guesser_mode guesser,
             std::vector&lt;tagged_lemma_forms&gt;&amp; forms) const;
</PRE>

<H4>5.2.3.1. Tag Wildcard</H4>

<P>
Optionally, a tag wildcard can be specified (or be <CODE>NULL</CODE>) and if so, results
are filtered using this wildcard. This method can be therefore used in more
ways: One may wish to generate all possible forms and their tags from a given
lemma. Then the <CODE>tag_wildcard</CODE> is set to <CODE>NULL</CODE> and the method generates
all possible combinations. One may also need a generate a specific form and tag
from a given lemma, then <CODE>tag_wildcard</CODE> is set to this tag value.
</P>
<P>
Or even more, for example, in the Czech positional morphology tagging system
(<A HREF="http://books.google.cz/books?id=sB63AAAACAAJ">Hajič 2004</A>),
one may even wish to generate something like "all forms in fourth case",
then <CODE>tag_wildcard</CODE> should be set to <CODE>????4</CODE>.
Please see Section "Czech Morphology" in User's Manual for more details about the Czech positional tagging system.
The previous example applies to morphological annotation applied to
<A HREF="http://ufal.mff.cuni.cz/pdt2.5/">PDT 2.5</A>, however, the tag wildcards can be used in any
morphological tagging system.
</P>
<P>
Most characters of a tag wildcard match corresponding characters of a tag, with the following exceptions:
</P>

 <UL>
 <LI><CODE>?</CODE> matches any character of a tag.
 <LI><CODE>[chars]</CODE> matches any of the characters listed. The dash <CODE>-</CODE> has no special meaning and if <CODE>]</CODE>
   is the first character in <CODE>chars</CODE>, it is considered as one of the characters and does not end the group.
 <LI><CODE>[^chars]</CODE> matches any of the characters <I>not</I> listed.
 </UL>

<H4>5.2.3.2. Unknown Lemmas</H4>

<P>
When the lemma is unknown, MorphoDiTa's generation behavior is defined by Guesser mode (see also
question Guesser Mode in Questions and Answers). If at least one lemma is found
in the dictionary, <CODE>NO_GUESSER</CODE> is returned. If <CODE>guesser == GUESSER</CODE> and the lemma
is found by the guesser, <CODE>GUESSER</CODE> is returned. Otherwise, forms are cleared and
<CODE>-1</CODE> is returned.
</P>

<A NAME="faq"></A>
<H2>5.3. Questions and Answers</H2>

<DL>
<DT><B>What is a Guesser Mode?</B></DT><DD>
  Morphological analysis may try to guess the lemma and tag of an uknown word.
  This option is turned on by <CODE>morpho::GUESSER</CODE> and off by
  <CODE>morpho::NO_GUESSER</CODE>.
<P></P>
<DT><B>Why `string_piece`` and not <CODE>const char*</CODE> or <CODE>std::string</CODE>?</B></DT><DD>
  We aim to make MorphoDiTa interface as effective as possible. Because the
  input strings may be substrings of larger text or come from different than
  C++ memory regions, we want to avoid the cost of <CODE>\\0</CODE> padding or
  <CODE>string</CODE> conversion. Nevertheless, both <CODE>const char*</CODE> and
  <CODE>std::string</CODE> can be used instead of a <CODE>string_piece</CODE> because of existing
  implicit conversion rules.
</DL>

<A NAME="toc48"></A>
<H1>6. MorphoDiTa API Reference</H1>

<P>
The MorphoDiTa API is defined in header <CODE>morphodita.h</CODE> and resides in
<CODE>ufal::morphodita</CODE> namespace.
</P>
<P>
The strings used in the MorphoDiTa API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).
</P>

<A NAME="versioning"></A>
<H2>6.1. MorphoDiTa Versioning</H2>

<P>
MorphoDiTa version consists of three numbers <I>major.minor.patch</I> with the
following semantics:
</P>

<UL>
<LI>Even <I>patch</I> versions denote stable releases, odd <I>patch</I> versions denote
  development releases.
<LI>Two versions with the same <I>major.minor</I> have the same API with the same
  behaviour, apart from bugs. Therefore, if only <I>patch</I> is increased, the
  new version is only a bug-fix release.
<LI>If two versions <I>v</I> and <I>u</I> have the same <I>major</I>, but <I>minor(v)</I> is
  greater than <I>minor(u)</I>, version <I>v</I> contains only additions to the API.
  In other words, the API of <I>u</I> is all present in <I>v</I> with the same
  behaviour (once again apart from bugs). It is therefore safe to upgrade to
  a newer MorphoDiTa version with the same <I>major</I>.
<LI>If two versions differ in <I>major</I>, their API may differ in any way.
</UL>

<A NAME="lemma_structure"></A>
<H2>6.2. Lemma Structure</H2>

<P>
The lemmas used by MorphoDiTa consist of three parts:
</P>

<OL>
<LI><I>raw lemma</I>: text form of the lemma. May not uniquely distinguish
  lemma meanings, lemma use cases etc.
<LI><I>lemma id</I>: together with raw lemma provide a unique identifier of the lemma,
  possibly including lemma meanings or use cases.
<LI><I>lemma comments</I>: additional comments for the given lemma.
</OL>

<P>
These parts are stored in one string and the boundaries between them can be
determined by
<A HREF="#morpho_raw_lemma_len"><CODE>morpho::raw_lemma_len</CODE></A> and
<A HREF="#morpho_lemma_id_len"><CODE>morpho::lemma_id_len</CODE></A> methods.
Analyzer and tagger always return lemma in this structured form. When
performing morphological generation, either <I>raw lemma</I> or both <I>raw lemma</I> and
<I>lemma id</I> can be specified, any <I>lemma comments</I> are ignored.
</P>

<A NAME="string_piece"></A>
<H2>6.3. Struct string_piece</H2>

<PRE>
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string&amp; str);
}
</PRE>

<P>
The <A HREF="#string_piece"><CODE>string_piece</CODE></A> is used for efficient string passing. The string
referenced in <A HREF="#string_piece"><CODE>string_piece</CODE></A> is not owned by it, so users have to make sure
the referenced string exists as long as the <A HREF="#string_piece"><CODE>string_piece</CODE></A>.
</P>

<A NAME="tagged_form"></A>
<H2>6.4. Struct tagged_form</H2>

<PRE>
struct tagged_form {
  std::string form;
  std::string tag;
};
</PRE>

<P>
The <A HREF="#tagged_form"><CODE>tagged_form</CODE></A> is a pair of strings used when obtaining a form and tag
pair.
</P>

<A NAME="tagged_lemma"></A>
<H2>6.5. Struct tagged_lemma</H2>

<PRE>
struct tagged_lemma {
  std::string lemma;
  std::string tag;
};
</PRE>

<P>
The <A HREF="#tagged_lemma"><CODE>tagged_lemma</CODE></A> is a pair of strings used when obtaining a lemma and tag
pair.
</P>

<A NAME="tagged_lemma_forms"></A>
<H2>6.6. Struct tagged_lemma_forms</H2>

<PRE>
struct tagged_lemma_forms {
  std::string lemma;
  std::vector&lt;<A HREF="#tagged_form">tagged_form</A>&gt; forms;
};
</PRE>

<P>
The <A HREF="#tagged_lemma_forms"><CODE>tagged_lemma_forms</CODE></A> represents a lemma and a list of tagged forms.
</P>

<A NAME="token_range"></A>
<H2>6.7. Struct token_range</H2>

<PRE>
struct token_range {
  size_t start;
  size_t length;
};
</PRE>

<P>
The <A HREF="#token_range"><CODE>token_range</CODE></A> represent a range of a token as returned by a <A HREF="#tokenizer">tokenizer</A>.
The <CODE>start</CODE> and <CODE>length</CODE> fields specify the token position in Unicode
characters, not in bytes of UTF-8 encoding.
</P>

<A NAME="version"></A>
<H2>6.8. Class version</H2>

<PRE>
class version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;

  static <A HREF="#version">version</A> <A HREF="#version_current">current</A>();
};
</PRE>

<P>
The <A HREF="#version"><CODE>version</CODE></A> class represents MorphoDiTa version.
See <A HREF="#versioning">MorphoDiTa Versioning</A> for more information.
</P>

<A NAME="version_current"></A>
<H3>6.8.1. version::current</H3>

<PRE>
static <A HREF="#version">version</A> current();
</PRE>

<P>
Returns current MorphoDiTa version.
</P>

<A NAME="tokenizer"></A>
<H2>6.9. Class tokenizer</H2>

<PRE>
class tokenizer {
 public:
  virtual ~tokenizer() {}

  virtual void <A HREF="#tokenizer_set_text">set_text</A>(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
  virtual bool <A HREF="#tokenizer_next_sentence">next_sentence</A>(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;

  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_vertical_tokenizer">new_vertical_tokenizer</A>();
  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_czech_tokenizer">new_czech_tokenizer</A>();
  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_english_tokenizer">new_english_tokenizer</A>();
  static <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tokenizer_new_generic_tokenizer">new_generic_tokenizer</A>();
};
</PRE>

<P>
The <A HREF="#tokenizer"><CODE>tokenizer</CODE></A> class performs segmentation and tokenization of given text.
The class is <I>not</I> threadsafe.
</P>
<P>
The <A HREF="#tokenizer"><CODE>tokenizer</CODE></A> instances can be obtained either directly using
static methods or through instances of <A HREF="#morpho"><CODE>morpho</CODE></A> and <A HREF="#tagger"><CODE>tagger</CODE></A>.
</P>

<A NAME="tokenizer_set_text"></A>
<H3>6.9.1. tokenizer::set_text</H3>

<PRE>
virtual void set_text(<A HREF="#string_piece">string_piece</A> text, bool make_copy = false) = 0;
</PRE>

<P>
Set the text which is to be tokenized.
</P>
<P>
If <CODE>make_copy</CODE> is <CODE>false</CODE>, only a reference to the given text is
stored and the user has to make sure it exists until the tokenizer
is released or <CODE>set_text</CODE> is called again. If <CODE>make_copy</CODE>
is <CODE>true</CODE>, a copy of the given text is made and retained until the
tokenizer is released or <CODE>set_text</CODE> is called again.
</P>

<A NAME="tokenizer_next_sentence"></A>
<H3>6.9.2. tokenizer::next_sentence</H3>

<PRE>
virtual bool next_sentence(std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;* forms, std::vector&lt;<A HREF="#token_range">token_range</A>&gt;* tokens) = 0;
</PRE>

<P>
Locate and return next sentence of the given text. Returns <CODE>true</CODE> when successful and <CODE>false</CODE> when
there are no more sentences in the given text. The arguments are filled with found tokens if not <CODE>NULL</CODE>.
The <CODE>forms</CODE> contain token ranges in bytes of UTF-8 encoding, the <CODE>tokens</CODE> contain token ranges
in Unicode characters.
</P>

<A NAME="tokenizer_new_vertical_tokenizer"></A>
<H3>6.9.3. tokenizer::new_vertical_tokenizer</H3>

<PRE>
static <A HREF="#tokenizer">tokenizer</A> new_vertical_tokenizer();
</PRE>

<P>
Returns a new instance of a vertical tokenizer, which considers every line to
be one token, with empty line denoting end of sentence. The user should delete
the instance after use.
</P>

<A NAME="tokenizer_new_czech_tokenizer"></A>
<H3>6.9.4. tokenizer::new_czech_tokenizer</H3>

<PRE>
static <A HREF="#tokenizer">tokenizer</A> new_czech_tokenizer();
</PRE>

<P>
Returns a new instance of a Czech tokenizer. The user should delete it after
use.
</P>

<A NAME="tokenizer_new_english_tokenizer"></A>
<H3>6.9.5. tokenizer::new_english_tokenizer</H3>

<PRE>
static <A HREF="#tokenizer">tokenizer</A> new_english_tokenizer();
</PRE>

<P>
Returns a new instance of a English tokenizer. The user should delete it after
use.
</P>

<A NAME="tokenizer_new_generic_tokenizer"></A>
<H3>6.9.6. tokenizer::new_generic_tokenizer</H3>

<PRE>
static <A HREF="#tokenizer">tokenizer</A> new_generic_tokenizer();
</PRE>

<P>
Returns a new instance of a generic tokenizer. The user should delete it after
use.
</P>

<A NAME="morpho"></A>
<H2>6.10. Class morpho</H2>

<PRE>
class morpho {
 public:
  virtual ~morpho() {}

  static <A HREF="#morpho">morpho</A>* <A HREF="#morpho_load_cstring">load</A>(const char* fname);
  static <A HREF="#morpho">morpho</A>* <A HREF="#morpho_load_FILE">load</A>(FILE* f);

  enum <A HREF="#morpho_guesser_mode">guesser_mode</A> { NO_GUESSER = 0, GUESSER = 1 };

  virtual int <A HREF="#morpho_analyze">analyze</A>(<A HREF="#string_piece">string_piece</A> form, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; lemmas) const = 0;
  virtual int <A HREF="#morpho_generate">generate</A>(<A HREF="#string_piece">string_piece</A> lemma, const char* tag_wildcard, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser,
                       std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;

  virtual int <A HREF="#morpho_raw_lemma_len">raw_lemma_len</A>(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
  virtual int <A HREF="#morpho_lemma_id_len">lemma_id_len</A>(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
  virtual int <A HREF="#morpho_raw_form_len">raw_form_len</A>(<A HREF="#string_piece">string_piece</A> form) const = 0;

  virtual <A HREF="#tokenizer">tokenizer</A>* <A HREF="#morpho_new_tokenizer">new_tokenizer</A>() const = 0;
};
</PRE>

<P>
A <A HREF="#morpho"><CODE>morpho</CODE></A> instance represents a morphological dictionary. Such a dictionary allow
morphological analysis, morphological generation provide information about lemma structure
and provides a suitable tokenizer. All methods are thread-safe.
</P>

<A NAME="morpho_load_cstring"></A>
<H3>6.10.1. morpho::load(const char*)</H3>

<PRE>
static <A HREF="#morpho">morpho</A>* load(const char* fname);
</PRE>

<P>
Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of <A HREF="#morpho"><CODE>morpho</CODE></A> which the user should delete
after use.
</P>

<A NAME="morpho_load_FILE"></A>
<H3>6.10.2. morpho::load(FILE*)</H3>

<PRE>
static <A HREF="#morpho">morpho</A>* load(FILE* f);
</PRE>

<P>
Factory method constructor. Accepts C file pointer of an opened file with the
model. Returns a pointer to an instance of <A HREF="#morpho"><CODE>morpho</CODE></A> which the user should
delete after use.
</P>

<A NAME="morpho_guesser_mode"></A>
<H3>6.10.3. morpho::guesser_mode</H3>

<PRE>
enum <A HREF="#morpho_guesser_mode">guesser_mode</A> { NO_GUESSER = 0, GUESSER = 1 };
</PRE>

<P>
Guesser mode defines behavior in case of unknown words. When set to
<CODE>GUESSER</CODE>, morpho tries to guess unknown words. When set to <CODE>NO_GUESSER</CODE>,
morpho does not guess unknown words.
</P>

<A NAME="morpho_analyze"></A>
<H3>6.10.4. morpho::analyze()</H3>

<PRE>
virtual int analyze(<A HREF="#string_piece">string_piece</A> form, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; lemmas) const = 0;
</PRE>

<P>
Perform morphological analysis of a form. The guesser parameter specifies whether
a guesser can be used if the form is not found in the dictionary. Output is
assigned to the lemmas vector.
</P>
<P>
If the form is found in the dictionary, analyses are assigned to lemmas
and <CODE>NO_GUESSER</CODE> returned. If <CODE>guesser == GUESSER</CODE> and the form analyses are
found using a guesser, they are assigned to lemmas and <CODE>GUESSER</CODE> is
returned.  Otherwise <CODE>-1</CODE> is returned and lemmas are filled with one
analysis containing given form as lemma and a tag for unknown word.
</P>

<A NAME="morpho_generate"></A>
<H3>6.10.5. morpho::generate()</H3>

<PRE>
virtual int generate(<A HREF="#string_piece">string_piece</A> lemmma, const char* tag_wildcard, <A HREF="#morpho_guesser_mode">guesser_mode</A> guesser,
                     std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;
</PRE>

<P>
Perform morphological generation of a lemma. Optionally a tag_wildcard can be
specified (or be <CODE>NULL</CODE>) and if so, results are filtered using this wildcard.
The guesser parameter speficies whether a guesser can be used if the lemma is
not found in the dictionary. Output is assigned to the forms vector.
</P>
<P>
Tag_wildcard can be either <CODE>NULL</CODE> or a wildcard applied to the results.
A <CODE>?</CODE> in the wildcard matches any character, <CODE>[bytes]</CODE> matches any of the
bytes and <CODE>[^bytes]</CODE> matches any byte different from the specified ones.
A <CODE>-</CODE> has no special meaning inside the bytes and if <CODE>]</CODE> is first in bytes,
it does not end the bytes group.
</P>
<P>
If the given lemma is only a raw lemma, all lemma ids with this raw lemma are
returned. Otherwise only matching lemma ids are returned, ignoring any lemma
comments. For every found lemma, matching forms are filtered using the
tag_wildcard. If at least one lemma is found in the dictionary, <CODE>NO_GUESSER</CODE>
is returned. If <CODE>guesser == GUESSER</CODE> and the lemma is found by the guesser,
<CODE>GUESSER</CODE> is returned. Otherwise, forms are cleared and <CODE>-1</CODE> is returned.
</P>

<A NAME="morpho_raw_lemma_len"></A>
<H3>6.10.6. morpho::raw_lemma_len</H3>

<PRE>
virtual int raw_lemma_len(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
</PRE>

<P>
When given a lemma returned by the dictionary, returns the length of
a <I>raw lemma</I> (see <A HREF="#lemma_structure">Lemma Structure</A>).
</P>

<A NAME="morpho_lemma_id_len"></A>
<H3>6.10.7. morpho::lemma_id_len</H3>

<PRE>
virtual int lemma_id_len(<A HREF="#string_piece">string_piece</A> lemma) const = 0;
</PRE>

<P>
When given a lemma returned by the dictionary, returns the length of
a <I>raw lemma</I> plus a <I>lemma id</I> (see <A HREF="#lemma_structure">Lemma Structure</A>).
Therefore, the substring of the original lemma of this length is a unique
lemma identifier. The rest of the original lemma are lemma comments which
do not identify the lemma.
</P>

<A NAME="morpho_raw_form_len"></A>
<H3>6.10.8. morpho::raw_form_len</H3>

<PRE>
virtual int raw_form_len(<A HREF="#string_piece">string_piece</A> form) const = 0;
</PRE>

<P>
When given a form, returns the length of a <I>raw form</I>. This is used only in
<I>external morphology model</I>, where form contains also morphological analyses,
and this call can return the length of the form without the analyses.
</P>

<A NAME="morpho_new_tokenizer"></A>
<H3>6.10.9. morpho::new_tokenizer</H3>

<PRE>
virtual <A HREF="#tokenizer">tokenizer</A>* new_tokenizer() const = 0;
</PRE>

<P>
Returns a new instance of a suitable tokenizer or <CODE>NULL</CODE> if no such tokenizer
exists. The user should delete it after use.
</P>

<A NAME="tagger"></A>
<H2>6.11. Class tagger</H2>

<PRE>
class tagger {
 public:
  virtual ~tagger() {}

  static <A HREF="#tagger">tagger</A>* <A HREF="#tagger_load_cstring">load</A>(const char* fname);
  static <A HREF="#tagger">tagger</A>* <A HREF="#tagger_load_FILE">load</A>(FILE* f);

  virtual const <A HREF="#morpho">morpho</A>* <A HREF="#tagger_get_morpho">get_morpho</A>() const = 0;

  virtual void <A HREF="#tagger_tag">tag</A>(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tags) const = 0;

  <A HREF="#tokenizer">tokenizer</A>* <A HREF="#tagger_new_tokenizer">new_tokenizer</A>() const = 0;
};
</PRE>

<P>
A <A HREF="#tagger"><CODE>tagger</CODE></A> instance represents a tagger, which perform disambiguation of
morphological analyses. All methods are thread-safe.
</P>

<A NAME="tagger_load_cstring"></A>
<H3>6.11.1. tagger::load(const char*)</H3>

<PRE>
static <A HREF="#tagger">tagger</A>* load(const char* fname);
</PRE>

<P>
Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of <A HREF="#tagger"><CODE>tagger</CODE></A> which the user should delete
after use.
</P>

<A NAME="tagger_load_FILE"></A>
<H3>6.11.2. tagger::load(FILE*)</H3>

<PRE>
static <A HREF="#tagger">tagger</A>* load(FILE* f);
</PRE>

<P>
Factory method constructor. Accepts C file pointer of an opened file with the
model. Returns a pointer to an instance of <A HREF="#tagger"><CODE>tagger</CODE></A> which the user should
delete after use.
</P>

<A NAME="tagger_get_morpho"></A>
<H3>6.11.3. tagger::get_morpho()</H3>

<PRE>
virtual const <A HREF="#morpho">morpho</A>* get_morpho() const = 0;
</PRE>

<P>
Returns a pointer to an instance of <A HREF="#morpho"><CODE>morpho</CODE></A> associated with the tagger. Do
not delete the pointer, it is owned by the tagger instance and deleted in the
tagger destructor.
</P>

<A NAME="tagger_tag"></A>
<H3>6.11.4. tagger::tag()</H3>

<PRE>
virtual void tag(const std::vector&lt;<A HREF="#string_piece">string_piece</A>&gt;&amp; forms, std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tags) const = 0;
</PRE>

<P>
Perform morphological analysis and subsequent disambiguation. Accepts
a <CODE>std::vector</CODE> of <A HREF="#string_piece"><CODE>string_piece</CODE></A> and fills the output vector of <A HREF="#tagged_lemma"><CODE>tagged_lemma</CODE></A>.
</P>

<A NAME="tagger_new_tokenizer"></A>
<H3>6.11.5. tagger::new_tokenizer</H3>

<PRE>
virtual <A HREF="#tokenizer">tokenizer</A>* new_tokenizer() const = 0;
</PRE>

<P>
Returns a new instance of a suitable tokenizer or <CODE>NULL</CODE> if no such tokenizer
exists. The user should delete it after use.  The call is equal to
<CODE><A HREF="#tagger_get_morpho">get_morpho()</A>-&gt;<A HREF="#morpho_new_tokenizer">new_tokenizer()</A></CODE>.
</P>

<A NAME="tagset_converter"></A>
<H2>6.12. Class tagset_converter</H2>

<PRE>
class tagset_converter {
 public:
  virtual ~tagset_converter() {}

  virtual void <A HREF="#tagset_converter_convert">convert</A>(<A HREF="#tagged_lemma">tagged_lemma</A>&amp; tagged_lemma) const = 0;
  virtual void <A HREF="#tagset_converter_convert_analyzed">convert_analyzed</A>(std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tagged_lemmas) const = 0;
  virtual void <A HREF="#tagset_converter_convert_generated">convert_generated</A>(std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;

  static <A HREF="#tagset_converter">tagset_converter*</A> <A HREF="#tagset_converter_new_identity_converter">new_identity_converter</A>();
  static <A HREF="#tagset_converter">tagset_converter*</A> <A HREF="#tagset_converter_new_pdt_to_conll2009_converter">new_pdt_to_conll2009_converter</A>();
};
</PRE>

<A NAME="tagset_converter_convert"></A>
<H3>6.12.1. tagset_converter::convert()</H3>

<PRE>
virtual void convert(<A HREF="#tagged_lemma">tagged_lemma</A>&amp; tagged_lemma) const = 0;
</PRE>

<P>
Convert the given tagged lemma.
</P>

<A NAME="tagset_converter_convert_analyzed"></A>
<H3>6.12.2. tagset_converter::convert_analyzed()</H3>

<PRE>
virtual void convert_analyzed(std::vector&lt;<A HREF="#tagged_lemma">tagged_lemma</A>&gt;&amp; tagged_lemmas) const = 0;
</PRE>

<P>
Convert the given results of <A HREF="#morpho_analyze">morpho::analyze</A>. Apart from calling
<A HREF="#tagset_converter_convert">convert</A>, any repeated entries are removed.
</P>

<A NAME="tagset_converter_convert_generated"></A>
<H3>6.12.3. tagset_converter::convert_generated()</H3>

<PRE>
virtual void convert_generated(std::vector&lt;<A HREF="#tagged_lemma_forms">tagged_lemma_forms</A>&gt;&amp; forms) const = 0;
</PRE>

<P>
Convert the given results of <A HREF="#morpho_generate">morpho::generate</A>. Apart from calling
<A HREF="#tagset_converter_convert">convert</A>, any repeated entries are removed.
</P>

<A NAME="tagset_converter_new_identity_converter"></A>
<H3>6.12.4. tagset_converter::new_identity_converter()</H3>

<PRE>
static <A HREF="#tagset_converter">tagset_converter*</A> new_identity_converter();
</PRE>

<P>
Returns a new instance of an identity converter. All convert methods of an
identity converter do nothing. The user should delete the instance after use.
</P>

<A NAME="tagset_converter_new_pdt_to_conll2009_converter"></A>
<H3>6.12.5. tagset_converter::new_pdt_to_conll2009_converter()</H3>

<PRE>
static <A HREF="#tagset_converter">tagset_converter*</A> new_pdt_to_conll2009_converter();
</PRE>

<P>
Returns a new instance of a Czech PDT tag set to CoNLL2009 tag set converter.
The user should delete the instance after use.
</P>
<P>
CoNLL2009 tag set uses two columns for tags &ndash; one is a POS and the other one
are additional FEATs. Because we have only one tag field, we merge these fields
together by using <CODE>Pos=?|FEAT</CODE>, i.e., the POS is stored as a first FEAT.
</P>

<A NAME="toc87"></A>
<H2>6.13. C++ Bindings API</H2>

<P>
Bindings for other languages than C++ are created using SWIG from the C++
bindings API, which is a slightly modified version of the native C++ API.
Main changes are replacement of <A HREF="#string_piece"><CODE>string_piece</CODE></A> type by native
strings and removal of methods using <CODE>FILE</CODE>. Here is the C++ bindings API
declaration:
</P>

<A NAME="toc88"></A>
<H3>6.13.1. Helper Structures</H3>

<PRE>
typedef vector&lt;string&gt; Forms;

struct TaggedForm {
  string form;
  string tag;
};
typedef vector&lt;TaggedForm&gt; TaggedForms;

struct TaggedLemma {
  string lemma;
  string tag;
};
typedef vector&lt;TaggedLemma&gt; TaggedLemmas;

struct TaggedLemmaForms {
  string lemma;
  TaggedForms forms;
};
typedef vector&lt;TaggedLemmaForms&gt; TaggedLemmasForms;

struct TokenRange {
  size_t start;
  size_t length;
};
typedef vector&lt;TokenRange&gt; TokenRanges;
</PRE>

<A NAME="toc89"></A>
<H3>6.13.2. Main Classes</H3>

<PRE>
class Version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;

  static Version current();
};

class Tokenizer {
 public:
  virtual void setText(const char* text);
  virtual bool nextSentence(Forms* forms, TokenRanges* tokens);

  static Tokenizer* newVerticalTokenizer();
  static Tokenizer* newCzechTokenizer();
  static Tokenizer* newEnglishTokenizer();
  static Tokenizer* newGenericTokenizer();
};

class Morpho {
 public:
  static Morpho* load(const char* fname);

  enum { NO_GUESSER = 0, GUESSER = 1 };

  virtual int analyze(const char* form, int guesser, TaggedLemmas&amp; lemmas) const;
  virtual int generate(const char* lemma, const char* tag_wildcard, int guesser, TaggedLemmasForms&amp; forms) const;
  virtual string rawLemma(const char* lemma) const;
  virtual string lemmaId(const char* lemma) const;
  virtual string rawForm(const char* form) const;

  virtual Tokenizer* newTokenizer() const;
};

class Tagger {
 public:
  static Tagger* load(const char* fname);

  virtual const Morpho* getMorpho() const;

  virtual void tag(Forms&amp; forms, TaggedLemmas&amp; tags) const;

  Tokenizer* newTokenizer() const;
};

class TagsetConverter {
 public:
  static TagsetConverter* newIdentityConverter();
  static TagsetConverter* newPdtToConll2009Converter();

  virtual void convert(TaggedLemma&amp; lemma) const;
  virtual void convertAnalyzed(TaggedLemmas&amp; lemmas) const;
  virtual void convertGenerated(TaggedLemmasForms&amp; forms) const;
};
</PRE>

<A NAME="toc90"></A>
<H2>6.14. Java Bindings</H2>

<P>
MorphoDiTa library bindings is available in the <CODE>cz.cuni.mff.ufal.morphodita</CODE>
package.
</P>
<P>
The bindings is a straightforward conversion of the <CODE>C++</CODE> bindings API.
Vectors do not have native Java interface, see
<CODE>cz.cuni.mff.ufal.morphodita.Forms</CODE> class for reference. Also, class members
are accessible and modifiable using using <CODE>getField</CODE> and <CODE>setField</CODE>
wrappers.
</P>
<P>
The bindings require native C++ library <CODE>morphodita_java</CODE> (called
<CODE>libmorphodita_java</CODE> on Linux). If the library is found in the current
directory, it is used, otherwise standard library search process is used.
</P>

<A NAME="toc91"></A>
<H2>6.15. Perl Bindings</H2>

<P>
MorphoDiTa library bindings is available in the
<A HREF="http://search.cpan.org/~straka/Ufal-MorphoDiTa/"><CODE>Ufal::MorphoDiTa</CODE></A> package.
The classes can be imported into the current namespace using the <CODE>:all</CODE>
export tag.
</P>
<P>
The bindings is a straightforward conversion of the <CODE>C++</CODE> bindings API.
Vectors do not have native Perl interface, see <CODE>Ufal::MorphoDiTa::Forms</CODE> for
reference. Static methods and enumerations are available only through the
module, not through object instance.
</P>

<A NAME="toc92"></A>
<H2>6.16. Python Bindings</H2>

<P>
MorphoDiTa library bindings is available in the
<A HREF="http://pypi.python.org/pypi/ufal.morphodita"><CODE>ufal.morphodita</CODE></A> module.
</P>
<P>
The bindings is a straightforward conversion of the <CODE>C++</CODE> bindings API.
In Python 2, strings can be both <CODE>unicode</CODE> and UTF-8 encoded <CODE>str</CODE>, and the
library always produces <CODE>unicode</CODE>. In Python 3, strings must be only <CODE>str</CODE>.
</P>

<A NAME="toc93"></A>
<H1>7. Contact</H1>

<P>
Authors:
</P>

<UL>
<LI><A HREF="http://ufal.mff.cuni.cz/milan-straka">Milan Straka</A>, <A HREF="mailto:straka@ufal.mff.cuni.cz">straka@ufal.mff.cuni.cz</A>
<LI><A HREF="http://ufal.mff.cuni.cz/jana-strakova">Jana Straková</A>, <A HREF="mailto:strakova@ufal.mff.cuni.cz">strakova@ufal.mff.cuni.cz</A>
</UL>

<P>
<A HREF="http://ufal.mff.cuni.cz/morphodita">MorphoDiTa website</A>.
</P>
<P>
<A HREF="http://hdl.handle.net/11858/00-097C-0000-0023-43CD-0">MorphoDiTa LINDAT/CLARIN entry</A>.
</P>

<A NAME="morphodita_acknowledgements"></A>
<H1>8. Acknowledgements</H1>

<P>
This work has been using language resources developed and/or stored and/or distributed by the LINDAT/CLARIN project of the Ministry of Education of the Czech Republic (project <I>LM2010013</I>).
</P>
<P>
Acknowledgements for individual language models are listed in MorphoDiTa User's Manual.
</P>

<A NAME="toc95"></A>
<H2>8.1. Publications</H2>

<UL>
<LI>(Spoustová et al. 2009) Drahomíra "johanka" Spoustová, Jan Hajič, Jan Raab, Miroslav Spousta. 2009. <I><A HREF="http://aclweb.org/anthology//E/E09/E09-1087.pdf">Semi-Supervised Training for the Averaged Perceptron POS Tagger.</A></I> In Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009), pages 763-771, Athens, Greece, March. Association for Computational Linguistics.
</UL>

<A NAME="toc96"></A>
<H2>8.2. Bibtex for referencing</H2>

<PRE>
@inproceedings{spoustova09,
  author = {Spoustov{\'a}, Drahom{\'\i}ra ``johanka'' and Haji\v{c}, Jan and Raab, Jan and Spousta, Miroslav},
  title = {Semi-{S}upervised {T}raining for the {A}veraged {P}erceptron {POS} {T}agger},
  booktitle = {Proceedings of the 12th Conference of the European Chapter of the ACL (EACL 2009)},
  month = {March},
  year = {2009},
  address = {Athens, Greece},
  publisher = {Association for Computational Linguistics},
  pages = {763--771},
  url = {http://www.aclweb.org/anthology/E09-1087}
}
</PRE>

</DIV>
<!-- html code generated by txt2tags 2.6 (http://txt2tags.org) -->
<!-- cmdline: txt2tags -t html -C not_web.conf morphodita.t2t -->
</BODY></HTML>
